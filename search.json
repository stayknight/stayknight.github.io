[{"title":"linux僵尸进程和孤儿进程一点记录","date":"2023-02-27T10:10:50.000Z","url":"/20230227-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["僵尸进程","/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":" 工作中偶尔会碰到僵尸进程问题，有时候同事也会来问，有时候自己也会遗忘搞不清，有必要记录一下。 进程基础 Linux进程是一棵树，除了根节点，每一个进程都由其父进程创建出来。根节点为init/systemd进程，进程号一般为1. 进程是一种系统资源，进程结束后，将由其父进程负责回收其剩余占用的系统资源。 孤儿进程进程退出时，若还有运行中的子进程，这些子进程就被称为孤儿进程。孤儿进程会被init/systemd收养，也就是孤儿进程的父进程会变成init/systemd。PS： ubuntu16.04以上，每个用户拥有一个独立的systemd进程，该用户运行的孤儿进程会被相应的systemd收养，故孤儿进程ID不一定是1. 孤儿进程本身不是一种问题。比如我们经常用脚本启动一个后台进程，脚本执行完毕退出，这个后台进程就经历了变孤儿然后被收养的流程。孤儿进程在开发中造成困扰通常是想要结束进程时，错误的结束了它的父进程，造成了误解。一个典型的例子就是： 在supervisor中配置了shell脚本作为应用的可执行路径，shell脚本启动真正的应用程序，然后用supervisor stop 停止应用却发觉应用没有正确停止，后台残留一个ppid为1的应用程序。 孤儿进程可以正常的被kill杀死。 僵尸进程进程退出后，在被父进程回收前的这段时间状态即为僵尸状态，每个进程都会经历这个过程。正常情况下，僵尸状态的进程会很快被父进程回收。但是若父进程太忙，陷入阻塞无法调用wait/waitpid()来清理子进程，那么进程就变成一个可见的僵尸进程存留于系统中。僵尸进程可以通过ps查看，STAT列值是Z/Z+/Zl/Zl+的就是僵尸进程，同时其COMMAND带有标志。 通常情况下，僵尸进程无法通过kill杀死，因为kill只是通知进程退出，但是僵尸进程本身是已调用过exit()后死亡等待回收的进程。解决的办法是杀死其父进程，让init/systemd来回收僵尸进程的资源。 可以被杀死的僵尸进程：对于多线程的应用，若主线程调用pthread_exit函数退出，其他线程将保持运行，此时进程无法被回收而显示出僵尸进程状态(Zl/Zl+)。这时候若用ps a -eLf查看，可以看到仅有主线程处于僵尸状态。此时可以通过kill &lt;进程ID&gt;杀死整个进程，而导致僵尸进程被回收。 附： 进程状态码 参考文档     "},{"title":"关于带返回值的函数未返回引起的Undefined Behavior问题","date":"2023-02-24T07:18:52.000Z","url":"/20230224-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/tags/C-%E5%9F%BA%E7%A1%80/"],["gcc","/tags/gcc/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E5%9F%BA%E7%A1%80/"]],"content":" 最近帮一个同事调试代码，遇到一个奇怪的double free崩溃问题，通过gdb定位到问题函数，发现问题出现在一个局部变量的析构函数中，最初没有关注到返回值问题，花了很多时间分析业务代码，结果找不出任何问题; 后来注意到返回值问题，想到gcc没有任何报错（用了-w屏蔽警告）, 而且测试问题函数内业务代码时，有时候也能修复，所以觉得应该与返回值无关，但是顺手修复后，bug就此消失了。后来上网查找了类似原因，原来是编译优化与UB的基础性问题，惭愧。 知乎讨论帖： 这个代码int函数无返回值且开-O2，for循环会无限循环，是什么原因？ 后经过测试，对于int函数漏返回值：ubuntu 18.04 gcc 7.5.0 -O2 编译器无警告，运行结果正确，没有触发UB行为ubuntu 20.04 gcc 9.4.0 -O2 -O1 编译器输出警告，运行触发UB行为，比如上面提到的double free或者 带条件for无限循环 等问题 结论： 进行C/C++程序开发时，非常有必要关注编译器版本，优化级别以及警告信息，尽量在打开警告(-Wall)时完成编译并认真对待警告。"},{"title":"前端打包构建工具整理：功能与区别","date":"2021-05-27T07:20:18.000Z","url":"/20210527-1.html","tags":[["webpack","/tags/webpack/"],["rollup","/tags/rollup/"],["snowpack","/tags/snowpack/"],["vite","/tags/vite/"]],"categories":[["前端开发","/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"]],"content":"前言据我了解，前端开发构建工具目前有两大类： bundle和no bundle, 其中,bundle类工具主要代表： webpack, parcel， rollup, esbuild.no bundle类主要代表： snowpack, vite. 在过去的几年，webpack之类的bundle打包工具，成为大多数web应用程序构建的必要步骤。这是因为： 在HTTP 1.x时代， 浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞，从而影响性能，因此合并请求非常有必要； 在以前的浏览器中， nodejs的CommonJS模块和ES模块，普遍都无法直接运行，必须转换处理，这也为bundler的存在提供了合理性。 bundle处理本身也有很多优点，比如webpack支持很多插件，可以支持各种文件处理以及混淆压缩等。 但是bundler的存在，却真实的增加了前端应用开发很多的复杂性，也一定程度影响开发效率， 比如bundle体积过大，热更新速度慢等。而且到了2020后的现代，以上的问题基本上都不复存在： http2多路复用，允许同时通过单一的http2连接发起多重的请求-响应消息。随着http2的普及，合并请求变得没那么必要。 浏览器普遍开始支持ESM模块。 no bundle构建工具普遍的一个特点就是配置相对简单， 启动和热更新快， 开发体验较好， 这样自然而然开始流行起来。比如vue 2.0用webpack， 到vue 3.0就抛弃webpack改用自研的vite工具了。 当然no bundle也不是真的no bundle， 毕竟bundle还是有很多优势的，在构建发布时也依然用到bundle工具, 如snowpack可以选择bundler如webpack，vite使用了rollup. 内容webpack官方描述： 本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。 rollup官方描述： Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验。 esbuild官方描述： An extremely fast JavaScript bundler. snowpack官方描述： Snowpack 是为现代浏览器设计的一个超级快的前端构建工具, 它是你在开发工作流程中使用更笨重更复杂的bundle打包工具如webpack, parcel的另一个可选方案。Snowpack利用JavaScript的本地模块系统(即ESM)来避免不必要的（转换）工作, 并在你无论你工程增长多大时保持运行快速。 vite官方描述： Vite 是一种新型前端构建工具，能够显著提升前端开发体验。(vite vue 3.0引入， 使用了esbuild + rollup, 集合两家之长) 小结webpack升级到5.x,依然是强大的主流选择，但是不再是一统天下了。esbuild 和 rollup 都是小巧玲珑，主打先进和快，仅用于javascript。vite 未来主要依然是用于vue 3.0的生态中。snowpack 朝大而全发展，支持react, vue, svelte等。"},{"title":"Linux环境下C/C++开发和可执行程序运行路径","date":"2021-03-15T06:20:21.000Z","url":"/20210315-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["C++基础","/tags/C-%E5%9F%BA%E7%A1%80/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":" 开发C++程序, 路径设置一直是一个容易出错的关键点。很多人入门C++很久，对于程序开发和运行相关路径还是云里雾里。这里做一个简单的梳理。因为现在C++开发一般都是CMake了，所以本文都以CMake举例。 C++开发中需要关注的路径 头文件路径： 头文件路径是编译器(如: cc, cc1)需要使用的路径。 依赖库文件路径： 依赖库文件路径是链接器(如: ld)需要使用的路径。 运行时路径： 程序运行时通常需要加载一些动态库，仅依赖当前系统环境，与开发设置无关，所以需要在系统环境中设置运行时路径。 GCC链接选项-L，-rpath-link，-rpath -L: 指定通过-l连接的动态库的搜索目录，所有的-L对所有的-l有效。 -rpath: 设置运行时库搜索路径，会写入ELF可执行文件中。 -rpath-link: 指定链接时间接依赖库搜索路径, 运行时无效。 LD_LIBRARY_PATH在程序链接或运行期间，如果设置了LD_LIBRARY_PATH， 链接器/运行时链接器都会搜索该路径查找动态库。 可执行程序运行时搜索库路径的几个点： 默认路径： /lib， /usr/lib 环境变量： LD_LIBRARY_PATH ELF中的RPATH ELF中的RUNPATH 其优先级关系如下：ELF中的RPATH|ELF中的RUNPATH|LD_LIBRARY_PATH环境变量|尝试加载目录的数序:=:|:=:|:=:|:=:未设置|未设置|未设置|/lib==&gt;/usr/lib未设置|未设置|设置|${LD_LIBRARY_PATH}==&gt;/lib==&gt;/usr/lib设置|未设置|未设置|${RPATH}==&gt;/lib==&gt;/usr/lib设置|未设置|设置|${RPATH}==&gt;${LD_LIBRARY_PATH}==&gt;/lib==&gt;/usr/lib设置或未设置|设置|设置|${LD_LIBRARY_PATH}==&gt;${RUN_PATH}==&gt;/lib==&gt;/usr/lib设置或未设置|设置|未设置|${RUN_PATH}==&gt;/lib==&gt;/usr/lib pkg-config和PKG_CONFIG_PATH许多程序和第三方库发布包提供一个*.pc的配置文件，里面也包含了头文件和依赖库等信息，用户通过设置PKG_CONFIG_PATH，就可以利用pkg-config工具解析并输出编译选项，将其用于gcc等编译器的编译链接过程中。如：$gcc main.c pkg-config --cflags --libs opencv -o main 参考：  CMake中设置头文件，依赖库路径和运行时路径 可能遇到的问题 设置了rpath, 但是运行时找不到so. "},{"title":"【转】【分享】80个网站源码","date":"2021-02-01T15:18:00.000Z","url":"/20210201-1.html","tags":[["资源分享","/tags/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"],["源码","/tags/%E6%BA%90%E7%A0%81/"]],"categories":[["资源分享","/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"],["源码","/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/%E6%BA%90%E7%A0%81/"]],"content":"2019帝国CMS7.5仿《ITBear科技资讯》源码链接:  提取码: svr9 YMYS009强大专业的x站链接:  提取码: gvuw 粉色小说网站链接:  提取码: kxai 酷黑音乐网链接:  提取码: te7e MKCMS米酷源码6.2链接:  提取码: vqex 2019最新笔趣阁全套链接:  提取码: c9kf 仿蜻蜓听书网链接:  提取码: 87g5 Xyplayer X3.91正式版链接:  提取码: at42 默笙工具箱V2.0 带后台链接:  提取码: 88pi 优客365导航链接:  提取码: idcf 蚂蚁魔盒源码链接:  提取码: f12x 骑士人才招聘系统5.2.6版链接:  提取码: rg4e 龙武链接:  提取码: 3ft8 php云人才网系统4.6.1源码链接:  提取码: ttrj PTCMS完整版V4.2.8链接:  提取码: 6dwj 2019最新盒子链接:  提取码: 4d49 趣头条新闻闻阅读源码链接:  提取码: jfnt 蜘蛛池站群源码链接:  提取码: 2ump 友价虚拟物品商城20191023版链接:  提取码: vkky 最新聚合支付系统源码链接:  提取码: k4re 全新任务悬赏平台链接:  提取码: d3vn 苹果cmsV10秘趣响应式链接:  提取码: w1b8 WordPress主题 LightSNS_1.5.204.1链接:  提取码: n38k 鹅之家机器人源码链接:  提取码: f546 米酷2019最新版 自动采集 安装教程链接:  提取码: w1e4 Discuz强制伪静态地址seoV5.3插件链接:  提取码: f3ef 优客365网址导航精华版1.1.6网站链接:  提取码: fstj 织梦dedecms电商信息新闻资讯模板链接:  提取码: nse1 抖音时钟html链接:  提取码: 8x6c 帝国cms 7.5大气高科技感网站模板链接:  提取码: baz8 柒上网络漫画系统3.0链接:  提取码: i748 江冉企业级APP分发链接:  提取码: rfwi MKCMS6.2.4新用户完整版链接:  提取码: s9hh 球球大作战源码链接:  提取码: j8vi riproV4.3PJ版链接:  提取码: fx99 Thinkphp内核仿拼多多源码链接:  提取码: 49na Thinkphp金多多广告机系统源码链接:  提取码: be2f PHPYUNV4.6.1人才招聘系统链接:  提取码: ekqz 最新仿知乎问答社区响应式源码带打赏功能链接:  提取码: hc5c ThinkPHP框架仿糗事百科笑话系统源码链接:  提取码: d2u4 PTCMS仿蜻蜓听书网带装图文教程版链接:  提取码: 45vt 百度网盘群组分享平台源码链接:  提取码: bfhp Timely 基于TP5.1开源客服系统链接:  提取码: 6ma9 系统之家下载站源码 thinkPHP框架链接:  提取码: 9vef 四合一中英文企业网站模板php源码链接:  提取码: 7u5k 仿《新趣头条》源码 娱乐游戏资讯网站模板链接:  提取码: ejai XyplayerX3.93 解析源码链接:  提取码: vyb3 WP主题 savoy 2.3.3链接:  提取码: eka2 苹果cmsV10含羞草网站源码链接:  提取码: s5s8 WEB机器人+酷Q开发的demo机器人链接:  提取码: 677p 随机小姐姐源码链接:  提取码: x47a 微信域名防封三合一链接:  提取码: 8rai 羊毛自动采集链接:  提取码: n3py 独立后台塔罗牌占卜爱情塔罗牌源码链接:  提取码: 323n ThinkPHP框架 非常漂亮UI红色网贷借款源码链接:  提取码: 3pyu 仿火币区块链交易所源码链接:  提取码: efgm E4A熊猫E4A源码链接:  提取码: q3hp 海洋CMS仿挖片网链接:  提取码: gcur WordPress简约响应式导航主题VIK链接:  提取码: scws 阿狸子订单系统豪华版链接:  提取码: nzxp 新版阿里能量树源码链接:  提取码: 88jt 全新188建站链接:  提取码: ixxf 小旋风蜘蛛池x4PJ版下载链接:  提取码: 34tm 阿里百秀XIU_v7.1后台解密无限制版链接:  提取码: 7euj WordPress主题 Inpandora主题模板链接:  提取码: tw81 彩虹5.8PJ版链接:  提取码: rxvg RiproV4.9.0商业版链接:  提取码: swjs 抖音去水印源码小程序独立版链接:  提取码: qdq6 YYCMS全自动CJ网站源码链接:  提取码: rpc8 素材解析8.0链接:  提取码: vnpt 微信分享邀请引流html页面源码链接:  提取码: 82ia PHP全自动采集在线高清壁纸网站源码链接:  提取码: c259 dux 6.1版链接:  提取码: hys6 扫地雷源码-独家修复+数据库+教程链接:  提取码: 54ic 微博红包链接:  提取码: 1raq 小涴熊漫画CMS链接:  提取码: zs9j 资源分享网整站链接:  提取码: fueu 2020点1头条链接:  提取码: nur2 NZ源码交易平台虚拟交易系统(商家版)链接:  提取码: dtus PHP短链接短网址生成源码V3.0链接:  提取码: q6iu PHP游戏陪玩平台源码 链接:  提取码: uwqr 92game精仿海盗湾站链接:  提取码: ehrm Vieu4.主题PJ版无授权链接:  提取码: 2p3b 小旋风万能蜘蛛池x5.1_PJ不限授权链接:  提取码: c8sn"},{"title":"Linux adb devices 显示no permissions问题解决","date":"2020-06-11T09:51:24.000Z","url":"/20200611-1.html","tags":[["linux","/tags/linux/"],["adb","/tags/adb/"],["lsusb","/tags/lsusb/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":" source:  1. adb的安装本人的Linux开发环境为Ubuntu Server 16.04，有使用其他平台，如CentOS等，可灵活变通。 2. no permissions安装好adb工具之后，连接安卓设备，并开启usb调试，使用adb devices发现显示出来的竟然是xxxxxxx no permissions 在网上查看到有相关解决方案: 首先，在未连接Android设备的情况下，用lsusb查看一下usb设备: 然后，打开android设备的usb调试模式，连接到Linux电脑上，再用lsusb查看一下usb设备: 如上则可以查看到新连接的Android设备信息，注意其ID号，这里是2207和0010，分别表示vendorID和productID。 然后cd /etc/udev/rules.d/目录下，在.rules文件(比如：custom-usb.rules)新增以下配置： 这里MODE表示权限。 给新增配置增加执行权限，并重启udev服务： 至此，拔掉usb重新连接，然后在运行如下命令，便可进行adb操作 3. adb devices为空若是运行adb devices列表为空，而lsusb却能看到已经连接的Android设备，此时可以 "},{"title":"各类MQTT代理服务器特性对比","date":"2020-06-04T09:51:24.000Z","url":"/20200604-1.html","tags":[["mqtt","/tags/mqtt/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":" From:  翻译如下： 本页试图记录各种MQTT服务器（代理）支持的特性。这是针对它们对MQTT的支持；其中很多服务器具有比MQTT更广泛的功能。 功能 备注QoS 0：服务质量 0，最多传输一次。QoS 1：服务质量1，至少传输一次。QoS 2：服务质量2，仅仅传输一次。auth：验证，身份验证授权。bridge：桥接，服务器代理之间连接$SYS：主题过滤器通配符，订阅后能够接收到所有以此通配符开头的主题的消息。dynamic topics：动态主题cluster：集群 Server QoS 0 QoS 1 QoS 2 auth Bridge $SYS SSL Dynamic topics cluster websockets plugin system Mqtt 5 support Active development Aedes ✔ ✔ ✔ Username/Password rm ✔ ✔ ✔ ✔ ✔ ✔ ✘ ✔ AWS IoT Services ✔ ✔ ✔ Client certificates ? ✘ ✔ § ✔ ✔ ✘ ✘ ✔ Apache ActiveMQ Artemis ✔ ✔ ✔ JAAS ✘ ✘ ✔ ✔ ✔ ✔ ✔ ✘ ✔ BevywiseIoTPlatform ✔ ✔ ✔ Key based ✔ ✔ ✔ ✔ ✔ ✔ rm ✘ ✔ ClearBlade ✔ ✔ ✔ OAuth based User/Pass &amp; Per-channel authorization ? ✔ ✔ ✔ ✔ ✔ ? ✘ ✔ ejabberd ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ emitter ✔ ✘ ✘ Per-channel authorization ✘ ✘ ✔ ✔ ✔ ✔ ✘ ✘ ✔ emqttd / EMQ ✔ ✔ ✔ Username/Password, JWT, LDAP, ClientID, … ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✘ ✔ flespi ✔ ✔ ✔ ✔ ✘ ✘ ✔ ✔ ✔ ✔ ✘ ✘ ✔ GnatMQ / M2MQTT ✔ ✔ ✔ Username/Password ✘ ✘ ✔ ✔ ✘ ✘ ✘ ✘ ✔ HBMQTT ✔ ✔ ✔ Username/Password, Client certificates ✔ ✔ ✔ ✔ ✘ ✔ ✔ ✘ ✔ HiveMQ ✔ ✔ ✔ Username/Password ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ IBM IoT MessageSight ✔ ✔ ✔ Username/Password ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✘ ✔ IBM Watson IoT Platform ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✘ ✔ IBM WebSphere MQ Middleware ✔ ✔ ✔ Username/Password, client certificate ✔ ✔ ✔ ✔ ✔ ✔ ✘ ✘ ✔ Jmqtt ✔ ✔ ✔ Username/Password, Client certificates ✔ ✔ ✔ ✔ ✘ ✔ ✔ ✘ ✔ JoramMQ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✘ ✘ Mongoose ✔ ✔ ✔ ✔ ✔ ✘ ✔ ✔ ✘ ✔ ✔ ✘ ✔ moquette ✔ ✔ ✔ ? ✔ ✘ ✔ ✔ rm ✔ ✘ ✘ ✔ mosca ✔ ✔ ✘ ✔ ✘ ✘ ✔ ✔ ✘ ✔ ✘ ✘ ✘ mosquitto ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ § ✔ ✔ ✘ ✔ MQTT.js ✔ ✔ ✔ § ✘ ✘ ✔ ✔ ✘ ✔ ✘ ✘ ✔ MQTTnet ✔ ✔ ✔ § § § ✔ ✔ § § § rm ✔ MqttWk ✔ ✔ ✔ ✔ ✔ ? ✔ ✔ ✔ ✔ ✘ ✘ ✔ RabbitMQ ✔ ✔ ✘ SASL ✘ ✘ ✔ ✔ ✔ ✔ ✔ ✘ ✔ Software AG Universal Messaging ✔ ✔ ✔ ✔ § ✘ ✔ ✔ § rm ✘ ✘ ✔ Solace ✔ ✔ ✘ Basic, client certificate, Kerberos § ✔ ✔ ✔ ✔ ✔ ✘ ✘ ✔ SwiftMQ ✔ ✔ ✔ ✔ ✔ ✘ ✔ ✔ ✔ ✘ ✔ ✘ ✔ TraferoTstack ✔ ✔ ✔ ✔ ✘ ✘ ✔ ✔ ✘ ✘ ✘ ✘ ✘ VerneMQ ✔ ✔ ✔ Username/Password ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✘ ✔ 说明 ✔ 表示支持 ✘ 表示不支持 ? 表示未知 § 表示支持但有限制 rm 表示(roadmap)路线图规划中也就是计划支持。 不再支持或已中止的软件和服务 2lemetry 已被 Amazon AWS 私下购买, 请看 the techcrunch article. Apache ActiveMQ Apollo 已中止, 请看 this link. JoramMQ 似乎已中止 IBM IoT Message gateway 现在变成了 IBM Watson IoT Platform. mosca 已中止 RSMB 现在变成了 Software AG Universal Messaging. 但是，其文档奇差无比。 TraferoTstack 自2017年以来没有更新， 已基本停止维护。 限制 AWS IoT Services 保留了一些以 $ 开头的主题. ClearBlade 保留了一些以 $ 开头的主题. mosquitto 的集群是在后端级别实现的(比如redis, amqp等)。 MQTT.js 接受提供用户名和密码的连接，但实际上并不对连接进行身份验证。 Software AG Universal Messaging 提供 Active/Active 集群（通过专有协议）和桥接（通过专有协议）。 Solace 没有提供一个broker之间专有的桥接方案. MQTTnet 提供客户端和服务器实现。所有特性可以按需扩展（或保留）。 这主要是面向.Net开发人员，以构建其自定义服务器和客户端实现。 但是，标准已经提供了许多功能。 "},{"title":"自动备份远程文件到本地","date":"2019-12-20T10:35:51.000Z","url":"/20191220-2.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["远程备份","/tags/%E8%BF%9C%E7%A8%8B%E5%A4%87%E4%BB%BD/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":" 自动登录远程机器，自动输入密码和yes/no等，可以利用expect，需要先安装。 自动备份远程机器上的文件(remote_bak.sh)： 自动备份远程机器数据库到本地: 创建crontab 大功告成！"},{"title":"数据库自动备份脚本","date":"2019-12-20T08:15:23.000Z","url":"/20191220-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据库","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"content":" 脚本mysqlbak.sh 创建crontab 大功告成！"},{"title":"过滤日志目录中所有日志里最近1小时的错误记录及上下5行","date":"2019-12-11T15:35:51.000Z","url":"/20191211-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":"这里假设日志文件中的时间标准格式为：[YYYY-mm-ddTHH:MM:SS.ZZZ]例如，日志格式： 命令： 解释： find ./ -type f -mmin -60 找到一小时以内修改过的文件 &#39;$1~/[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;/ 匹配日期行，对于日期行执行后面大括号的动作 t=substr($1,2,19); 取中括号中的日期 h=strftime(&quot;%Y-%m-%dT%T&quot;, systime()-3600); 取当前时间一个小时前的日期 if(t&gt;h)&#123;print $0; curline=NR&#125; 比较日期，如果在一小时内，则打印该行，并记录当前行号 curline&gt;0&amp;&amp;NR&gt;curline&amp;&amp;NR&lt;=curline+999 匹配上一次打印的日期行后面的行，尽量覆盖直至下一个日期行，匹配到就执行后面的大括号里的动作 if (FNR==1) &#123;curline=0&#125; else &#123;print $0&#125; 如果切换了下一个文件，就重置匹配日期行记录（不然后面的文件假如开头不是符合条件的行也都会打印出来），否则就继续打印当前文件的剩余行 grep &quot;ERROR&quot; -A 5 -B 5 在前面打印的所有行中将ERROR前后5行过滤出来 "},{"title":"Mongoose中使用shortid遇到的坑","date":"2019-11-28T09:51:24.000Z","url":"/20191128-1.html","tags":[["nodejs","/tags/nodejs/"],["mongoose","/tags/mongoose/"],["shortid","/tags/shortid/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":" mongoose用的不多，感觉还挺好用，对比mysql/mariadb的orm如sequelize, bookshelf等，要灵活的多，不过其接口和参数比较多，有一些默认的行为，用起来需要比较小心，要多进行测试。 shortid 是一个比较不错的生成较短的唯一ID的库，根据前人经验和shortid文档，将mongodb document的默认_id设置为shortid，感觉是个不错的主意。但是经过使用，我碰到了一些棘手的问题，然后我打算放弃使用shortid。 很多开源的小项目中使用shortid定义_id是这样的： 这样挺好（如果使用时提前知道一些潜在问题并规避的话），有些问答文章中答主这么写： 我不知道是版本问题还是答主想当然，这样是会报错的: 也就是你可以自定义_id的类型和默认值，但是不能自定义其相关索引。那么自定义类型和默认值就没有问题了吗？事实上，我没有在任何官方的说法中看到以上用法。而事实上确实有些问题（也就是上面说的需要规避的）, 我碰到有下面几点： Model.findOneAndUpdate(cond, data, {upsert: true}) 调用mongodb的findAndModify函数，这样会跳过我们的_id定义，在插入数据是生成ObjectId类型的_id; 导致后续查询失败。 Model.create函数更神奇：当传递array做参数时，会好好调用shortid.generate生成_id，当传递单个object, 则生成ObjectId。从mongoose官方文档上你看不出来为什么会有这个区别（代码上我也没看出来，没有更深入debug）。 这俩问题暂时都没有找到很好的解决办法，只能规避；想用shortid，创建时记得用Model.create(array)或这document.save。"},{"title":"完全卸载删除gitlab","date":"2019-10-18T09:51:24.000Z","url":"/20191018-1.html","tags":[["gitlab","/tags/gitlab/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":" &gt;&gt;本文来源 gitlab 项目比较庞大，卸载起来有点麻烦，所以这里记录一下。 1、停止gitlab 2、卸载gitlab（注意这里写的是gitlab-ce） 3、查看gitlab进程 4、杀掉第一个进程（就是带有好多………….的进程） 杀掉后，在ps aux | grep gitlab确认一遍，还有没有gitlab的进程 5、删除所有包含gitlab文件"},{"title":"Authentication in MariaDB 10.4 (MariaDB 10.4 root账号密码问题)","date":"2019-10-12T09:51:24.000Z","url":"/20191012-1.html","tags":[["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["mariadb","/tags/mariadb/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":" 昨天更换工作电脑，重装了一下ubuntu下的mariadb，ubuntu默认源下的mariadb 是10.0 版本，默认charset 是utf8mb4, 使用sequelize不好解决Index column size too large. The maximum column size is 767 bytes.限制的问题，遂去官网换了10.4版本。结果安装好了又怎么都登录不上去，用mysqld_safe --skip-grant-tables进去设置root密码，又碰到Column &#39;Password&#39; is not updatable，无法修改密码，无奈只好去官网看看是不是又出幺蛾子了，一找还真是有一篇文章讲这个问题，现把原文摘录贴过来备忘。 Authentication in MariaDB 10.4 — Understanding the Changes (original link)In a nutshell (简要)The password storage has changed. All user accounts, passwords, and global privileges are now stored in a mysql.global_priv table. What happened to the mysql.user table? It still exists and has exactly the same set of columns as before, but it’s now a view over mysql.global_priv. If you happen to have tools that analyze mysql.user table — they should continue working as before. 为什么改不了密码这里说的很清楚了，mysql.user表不见了，现在它只是mysql.global_priv表的一个视图。所以严格来说也不是不能改密码，只是不能修改原来的mysql.user表了。 One can specify more than one authentication method per account. They all will work as alternatives. For example, a DBA might start migrating users to the more secure ed25519 password plugin, but keep the old SHA1 one as an alternative for the transitional period. mariadb 10.4 可以给用户设置多种认证方式了，这里有需要的话再看。 The default authentication for new installations is now more secure. The open-for-everyone all-powerful root account is gone, at last. And installation scripts will no longer shout at you “PLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER !”, because the root account is created secure automatically. 很好很直接，root密码没了， 也不需要你去设置初始密码了，而且说是这样更安全，什么黑科技？看下面。 DetailsTechnically, a new MariaDB installation will have two all-powerful accounts — root and the OS user that owns the data directory, typically mysql. They are created as Using unix_socket means that if you are the system root user, you can login as root@locahost without a password. This technique was pioneered by Otto Kekäläinen in MariaDB packages in Debian as early as MariaDB 10.0. It is based on a simple fact, that asking the system root for a password adds no extra security — root has full access to all the data files and all process memory anyway. But not asking for a password means, there is no root password to forget (bye-bye numerous tutorials “how to reset MariaDB root password”). And if you want to script some tedious database work, there is no need to store the root password in plain text for the scipt to use (bye-bye debian-sys-maint user). mariadb 10.4安装时创建了2个默认账号: root，mysql。初始只提供了unix_socket方式认证。这样登录mysql你就不需要mysql -uroot -p了， 直接sudo mysql，只要你有系统root权限就可以进去。 Still, some users complained that they want to log in as MariaDB root without using sudo. This is why in 10.4 the root user has a second authentication method — conventional MariaDB password. By default it is disabled (“invalid” is not a valid password hash), but one can set the password with a usual SET PASSWORD statement. And still retain the password-less access via sudo! 如果你不想用sudo登录mysql, mariadb 10.4依然提供了传统的密码登录的方式，只是初始是禁用的(invalid)。你可以登录进mysql用SET PASSWORD的方式设置密码。 Now, what happens, if you install MariaDB locally (for example, from a tarball)? You definitely would not want to use sudo to be able to login. This is why MariaDB creates a second all-powerful user with the same name as a system user that owns the data directory. In local (not system-wide) installations, this will be the user, who installed MariaDB — she automatically gets convenient password-less root-like access, because, frankly, she can access all the data files anyway. And even if MariaDB is installed system-wide, you may not want to run your database maintenance scripts as system root — now you can run them as system mysql user. And you will know, that they will never destroy your entire system, even if you make a typo in a shell script. mariadb 10.4 在linux创建了mysql用户，所有数据文件都在mysql用户下面，所以它在数据库里也一并创建了unix_socket认证的mysql 用户，这样你可以不在用root和sudo的情况下通过mysql用户无密码操作数据库，而且也不用担心rm -rf不小心删除系统的问题，这对于脚本操作非常有用。 Cookbook（下面就不翻译或解释了) “This is all great”, you may be thinking, “but I’m a seasoned MariaDB DBA, I can write SQL in my sleep, do I need to do something different from now on”? Unfortunately, yes. After installing MariaDB system-wide the first thing you’ve got used to doing is logging in into the unprotected root account and protecting it, that is, setting the root password: This is not only unnecessary now, it will simply not work — there is no unprotected root account. To login as root use Note that it implies you are connecting via the unix socket, not tcp. If you happen to have protocol=tcp in a system-wide /etc/my.cnf file, use sudo mysql --protocol=socket. After installing MariaDB locally you’ve also used to connect to the unprotected root account using mysql -uroot. It will not work either, use simply mysql without specifying a username. You want passwords back, no unix_socket authentication anymore? Run Forgot your root password? No problem — you can still connect using sudo and change the password. Oh, you have also removed unix_socket authentication? In that case, do as follows: restart MariaDB with --skip-grant-tables login into the unprotected server run FLUSH PRIVILEGES (note, before 10.4 it would’ve been the last step, not anymore) run SET PASSWORD FOR root@localhost to change the root password You want to peek inside privilege tables? Old mysql.user table still exists, you can select from it as before, although you cannot update it anymore. It doesn’t show alternative authentication plugins? Yes, this was one of the reasons for switching to mysql.global_priv table — complex authentication rules did not fit into rigid structure of a relational table. But you can, of course, select from the new table too. For example, with This is it. Remember, the best way to keep your password safe is not to have one. And have fun!"},{"title":"github算法面试资料(Java版)","date":"2019-09-18T09:51:24.000Z","url":"/20190918-2.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["面试资料","/tags/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"]],"content":"Interviews Maintainer - Kevin Naughton Jr. Translations 简体中文 Table of Contents YouTube Instagram Articles Online Judges Live Coding Practice Data Structures Algorithms Greedy Algorithms Bitmasks Runtime Analysis Video Lectures Interview Books Computer Science News Directory Tree YouTube Kevin Naughton Jr. Instagram Programeme Articles Starting Work Online Judges LeetCode Virtual Judge CareerCup HackerRank CodeFights Kattis HackerEarth Codility Code Forces Code Chef Sphere Online Judge - SPOJ InterviewBit Live Coding Practice Pramp Gainlo Refdash Interviewing.io Data StructuresLinked List A Linked List is a linear collection of data elements, called nodes, eachpointing to the next node by means of a pointer. It is a data structureconsisting of a group of nodes which together represent a sequence. Singly-linked list: linked list in which each node points to the next node and the last node points to null Doubly-linked list: linked list in which each node has two pointers, p and n, such that p points to the previous node and n points to the next node; the last node’s n pointer points to null Circular-linked list: linked list in which each node points to the next node and the last node points back to the first node Time Complexity: Access: O(n) Search: O(n) Insert: O(1) Remove: O(1) Stack A Stack is a collection of elements, with two principle operations: push, which adds to the collection, andpop, which removes the most recently added element Last in, first out data structure (LIFO): the most recently added object is the first to be removed Time Complexity: Access: O(n) Search: O(n) Insert: O(1) Remove: O(1) Queue A Queue is a collection of elements, supporting two principle operations: enqueue, which inserts an elementinto the queue, and dequeue, which removes an element from the queue First in, first out data structure (FIFO): the oldest added object is the first to be removed Time Complexity: Access: O(n) Search: O(n) Insert: O(1) Remove: O(1) Tree A Tree is an undirected, connected, acyclic graph Binary Tree A Binary Tree is a tree data structure in which each node has at most two children, which are referred to asthe left child and right child Full Tree: a tree in which every node has either 0 or 2 children Perfect Binary Tree: a binary tree in which all interior nodes have two children and all leave have the same depth Complete Tree: a binary tree in which every level except possibly the last is full and all nodes in the lastlevel are as far left as possible Binary Search Tree A binary search tree, sometimes called BST, is a type of binary tree which maintains the property that the value in eachnode must be greater than or equal to any value stored in the left sub-tree, and less than or equal to any value storedin the right sub-tree Time Complexity: Access: O(log(n)) Search: O(log(n)) Insert: O(log(n)) Remove: O(log(n)) Trie A trie, sometimes called a radix or prefix tree, is a kind of search tree that is used to store a dynamic set or associativearray where the keys are usually Strings. No node in the tree stores the key associated with that node; instead, its positionin the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the String associatedwith that node, and the root is associated with the empty String. Fenwick Tree A Fenwick tree, sometimes called a binary indexed tree, is a tree in concept, but in practice is implemented as an implicit datastructure using an array. Given an index in the array representing a vertex, the index of a vertex’s parent or child is calculatedthrough bitwise operations on the binary representation of its index. Each element of the array contains the pre-calculated sum ofa range of values, and by combining that sum with additional ranges encountered during an upward traversal to the root, the prefixsum is calculated Time Complexity: Range Sum: O(log(n)) Update: O(log(n)) Segment Tree A Segment tree, is a tree data structure for storing intervals, or segments. It allows querying which of the stored segments containa given point Time Complexity: Range Query: O(log(n)) Update: O(log(n)) Heap A Heap is a specialized tree based structure data structure that satisfies the heap property: if A is a parent node ofB, then the key (the value) of node A is ordered with respect to the key of node B with the same ordering applying across the entire heap.A heap can be classified further as either a “max heap” or a “min heap”. In a max heap, the keys of parent nodes are always greaterthan or equal to those of the children and the highest key is in the root node. In a min heap, the keys of parent nodes are less thanor equal to those of the children and the lowest key is in the root node Time Complexity: Access Max / Min: O(1) Insert: O(log(n)) Remove Max / Min: O(log(n)) Hashing Hashing is used to map data of an arbitrary size to data of a fixed size. The values returned by a hashfunction are called hash values, hash codes, or simply hashes. If two keys map to the same value, a collision occurs Hash Map: a hash map is a structure that can map keys to values. A hash map uses a hash function to computean index into an array of buckets or slots, from which the desired value can be found. Collision Resolution Separate Chaining: in separate chaining, each bucket is independent, and contains a list of entries for each index. Thetime for hash map operations is the time to find the bucket (constant time), plus the time to iterate through the list Open Addressing: in open addressing, when a new entry is inserted, the buckets are examined, starting with thehashed-to-slot and proceeding in some sequence, until an unoccupied slot is found. The name open addressing refers tothe fact that the location of an item is not always determined by its hash value Graph A Graph is an ordered pair of G = (V, E) comprising a set V of vertices or nodes together with a set E of edges or arcs,which are 2-element subsets of V (i.e. an edge is associated with two vertices, and that association takes the form of theunordered pair comprising those two vertices) Undirected Graph: a graph in which the adjacency relation is symmetric. So if there exists an edge from node u to nodev (u -&gt; v), then it is also the case that there exists an edge from node v to node u (v -&gt; u) Directed Graph: a graph in which the adjacency relation is not symmetric. So if there exists an edge from node u to node v(u -&gt; v), this does not imply that there exists an edge from node v to node u (v -&gt; u) AlgorithmsSortingQuicksort Stable: No Time Complexity: Best Case: O(nlog(n)) Worst Case: O(n^2) Average Case: O(nlog(n)) Mergesort Mergesort is also a divide and conquer algorithm. It continuously divides an array into two halves, recurses on both theleft subarray and right subarray and then merges the two sorted halves Stable: Yes Time Complexity: Best Case: O(nlog(n)) Worst Case: O(nlog(n)) Average Case: O(nlog(n)) Bucket Sort Bucket Sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucketis then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm Time Complexity: Best Case: Ω(n + k) Worst Case: O(n^2) Average Case:Θ(n + k) Radix Sort Radix Sort is a sorting algorithm that like bucket sort, distributes elements of an array into a number of buckets. However, radixsort differs from bucket sort by ‘re-bucketing’ the array after the initial pass as opposed to sorting each bucket and merging Time Complexity: Best Case: Ω(nk) Worst Case: O(nk) Average Case: Θ(nk) Graph AlgorithmsDepth First Search Depth First Search is a graph traversal algorithm which explores as far as possible along each branch before backtracking Time Complexity: O(|V| + |E|) Breadth First Search Breadth First Search is a graph traversal algorithm which explores the neighbor nodes first, before moving to the nextlevel neighbors Time Complexity: O(|V| + |E|) Topological Sort Topological Sort is the linear ordering of a directed graph’s nodes such that for every edge from node u to node v, ucomes before v in the ordering Time Complexity: O(|V| + |E|) Dijkstra’s Algorithm Dijkstra’s Algorithm is an algorithm for finding the shortest path between nodes in a graph Time Complexity: O(|V|^2) Bellman-Ford Algorithm Bellman-Ford Algorithm is an algorithm that computes the shortest paths from a single source node to all other nodes in a weighted graph Although it is slower than Dijkstra’s, it is more versatile, as it is capable of handling graphs in which some of the edge weights arenegative numbers Time Complexity: Best Case: O(|E|) Worst Case: O(|V||E|) Floyd-Warshall Algorithm Floyd-Warshall Algorithm is an algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights, butno negative cycles A single execution of the algorithm will find the lengths (summed weights) of the shortest paths between all pairs of nodes Time Complexity: Best Case: O(|V|^3) Worst Case: O(|V|^3) Average Case: O(|V|^3) Prim’s Algorithm Prim’s Algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. In other words, Prim’s find asubset of edges that forms a tree that includes every node in the graph Time Complexity: O(|V|^2) Kruskal’s Algorithm Kruskal’s Algorithm is also a greedy algorithm that finds a minimum spanning tree in a graph. However, in Kruskal’s, the graph does nothave to be connected Time Complexity: O(|E|log|V|) Greedy Algorithms Greedy Algorithms are algorithms that make locally optimal choices at each step in the hope of eventually reaching the globally optimal solution Problems must exhibit two properties in order to implement a Greedy solution: Optimal Substructure An optimal solution to the problem contains optimal solutions to the given problem’s subproblems The Greedy Property An optimal solution is reached by “greedily” choosing the locally optimal choice without ever reconsidering previous choices Example - Coin Change Given a target amount V cents and a list of denominations of n coins, i.e. we have coinValue[i] (in cents) for coin types i from [0…n - 1],what is the minimum number of coins that we must use to represent amount V? Assume that we have an unlimited supply of coins of any type Coins - Penny (1 cent), Nickel (5 cents), Dime (10 cents), Quarter (25 cents) Assume V = 41. We can use the Greedy algorithm of continuously selecting the largest coin denomination less than or equal to V, subtract thatcoin’s value from V, and repeat. V = 41 | 0 coins used V = 16 | 1 coin used (41 - 25 = 16) V = 6 | 2 coins used (16 - 10 = 6) V = 1 | 3 coins used (6 - 5 = 1) V = 0 | 4 coins used (1 - 1 = 0) Using this algorithm, we arrive at a total of 4 coins which is optimal Bitmasks Bitmasking is a technique used to perform operations at the bit level. Leveraging bitmasks often leads to faster runtime complexity andhelps limit memory usage Test kth bit: s &amp; (1 &lt;&lt; k); Set kth bit: s |= (1 &lt;&lt; k); Turn off kth bit: s &amp;= ~(1 &lt;&lt; k); Toggle kth bit: s ^= (1 &lt;&lt; k); Multiple by 2n: s &lt;&lt; n; Divide by 2n: s &gt;&gt; n; Intersection: s &amp; t; Union: s | t; Set Subtraction: s &amp; ~t; Extract lowest set bit: s &amp; (-s); Extract lowest unset bit: ~s &amp; (s + 1); Swap Values: Runtime AnalysisBig O Notation Big O Notation is used to describe the upper bound of a particular algorithm. Big O is used to describe worst case scenarios Little O Notation Little O Notation is also used to describe an upper bound of a particular algorithm; however, Little O provides a boundthat is not asymptotically tight Big Ω Omega Notation Big Omega Notation is used to provide an asymptotic lower bound on a particular algorithm Little ω Omega Notation Little Omega Notation is used to provide a lower bound on a particular algorithm that is not asymptotically tight Theta Θ Notation Theta Notation is used to provide a bound on a particular algorithm such that it can be “sandwiched” betweentwo constants (one for an upper limit and one for a lower limit) for sufficiently large values Video Lectures Data Structures UC Berkeley Data Structures MIT Advanced Data Structures Algorithms MIT Introduction to Algorithms MIT Advanced Algorithms UC Berkeley Algorithms Interview Books Competitive Programming 3 - Steven Halim &amp; Felix Halim Cracking The Coding Interview - Gayle Laakmann McDowell Cracking The PM Interview - Gayle Laakmann McDowell &amp; Jackie Bavaro Introduction to Algorithms - Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest &amp; Clifford Stein Computer Science News Hacker News Lobsters "},{"title":"基本算法复杂度统计","date":"2019-09-18T08:51:24.000Z","url":"/20190918-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["算法复杂度","/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"]],"content":"Big O NotationBig O notation is used to classify algorithms according to how their running time or space requirements grow as the input size grows.On the chart below you may find most common orders of growth of algorithms specified in Big O notation. Source: Big O Cheat Sheet. Below is the list of some of the most used Big O notations and their performance comparisons against different sizes of the input data. Big O Notation Computations for 10 elements Computations for 100 elements Computations for 1000 elements O(1) 1 1 1 O(log N) 3 6 9 O(N) 10 100 1000 O(N log N) 30 600 9000 O(N^2) 100 10000 1000000 O(2^N) 1024 1.26e+29 1.07e+301 O(N!) 3628800 9.3e+157 4.02e+2567 Data Structure Operations Complexity Data Structure Access Search Insertion Deletion Comments Array 1 n n n Stack n n 1 1 Queue n n 1 1 Linked List n n 1 n Hash Table - n n n In case of perfect hash function costs would be O(1) Binary Search Tree n n n n In case of balanced tree costs would be O(log(n)) B-Tree log(n) log(n) log(n) log(n) Red-Black Tree log(n) log(n) log(n) log(n) AVL Tree log(n) log(n) log(n) log(n) Bloom Filter - 1 1 - False positives are possible while searching Array Sorting Algorithms Complexity Name Best Average Worst Memory Stable Comments Bubble sort n n2 n2 1 Yes Insertion sort n n2 n2 1 Yes Selection sort n2 n2 n2 1 No Heap sort n&nbsp;log(n) n&nbsp;log(n) n&nbsp;log(n) 1 No Merge sort n&nbsp;log(n) n&nbsp;log(n) n&nbsp;log(n) n Yes Quick sort n&nbsp;log(n) n&nbsp;log(n) n2 log(n) No Quicksort is usually done in-place with O(log(n)) stack space Shell sort n&nbsp;log(n) depends on gap sequence n&nbsp;(log(n))2 1 No Counting sort n + r n + r n + r n + r Yes r - biggest number in array Radix sort n * k n * k n * k n + k Yes k - length of longest key "},{"title":"linux命令netstat的几个用法","date":"2019-07-26T06:44:11.000Z","url":"/20190726-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["netstat","/tags/netstat/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":"Netstat 简介Netstat 是linux下的一款命令行工具，可用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，还能列出处于监听状态（即等待接入请求）的套接字。如果你想查看系统某一个端口是否被占用，就可以用netstat命令。另外netstat还可以列出本机路由信息和网络接口信息等。 1. 列出网络连接 由于netstat命令参数比较多，查看网络连接相关，常用的就是上面这些， 这里为了方便记忆组合了下：an tuple, 两个简单的英文单词～ 参数说明： -a: –all, 显示所有连接的socket (默认: connected) -n: –numeric, 不解析名称，包括主机名，端口名和用户名 -t: –tcp, 只显示tcp连接 -u: –udp, 只显示udp连接 -p: –programs, 显示连接进程的PID或进程名 -l: –listening, 显示正在监听的socket -e: –extend, 显示更多信息,包括连接进程的用户名等 注意： 将 -n 和 -e 选项一起使用，会列出用户的 ID 号，而不是用户名。 使用 -p 选项时，netstat 必须运行在 root 权限之下，不然它就不能得到运行在 root 权限下的进程名，而很多服务包括 http 和 ftp 都运行在 root 权限之下。 2. 显示内核路由信息 使用 -r 选项打印内核路由信息。打印出来的信息与 route 命令输出的信息一样。也可以使用 -n 选项禁止名称解析。 参数说明： -r: –route, 显示内核路由信息 -n: 与上面相同 3. 显示网络接口信息 使用 -i 选项可以输出网络接口信息， 但是输出的信息比较原始。搭配 -e 选项，可以输出用户友好的信息，输出结果与 ifconfig 一样。 参数说明： -i: –interfaces, 显示网络接口信息 -e: 与上面相同 4. 其他选项 -s: –statistics, 显示统计数据 -g: –groups, 显示多播，组播信息 -c: –continuous, 持续打印信息 5. 用法举例5.1 打印 active 状态的连接active 状态的套接字连接用 “ESTABLISHED” 字段表示，所以我们可以使用 grep 命令获得 active 状态的连接： 配合 watch 命令监视 active 状态的连接： 5.2 查看服务是否在运行比如查看mysql服务： "},{"title":"sequelize引起mysql错误：Too many keys specified. Max 64 keys allowed","date":"2019-07-24T14:22:08.000Z","url":"/20190724-1.html","tags":[["mysql","/tags/mysql/"],["sequelize","/tags/sequelize/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":"一个项目中使用sequelize作为mysql的ORM，项目已经发布运行快一个月了，最近查看日志，发现了如标题中的mysql错误，让我感觉十分莫名其妙。进入mysql控制台一看，简直吓一跳，几乎所有的表都一堆的unique index，这还怎么玩！ 赶紧想办法解决，一个个删肯定不可取，况且表的创建和修改都是sequelize自动执行的，你删了它再给你加。经过多方查找，发觉这是sequelize早已存在的一个BUG：如果用column: &#123;unique: true&#125;，当执行sequelize.sync({alter: true})的时候，每次执行都会新加一个index (column, column_2, column_3, …)， 蛋疼无比， sequelize官方也真够任性的，就是不改。 还好的是，sequelize也提供了一个解决办法： 不要用unique: true!!! 已经创建的海量的unique索引怎么办？用下面的语句来配合删除： 上面的语句会输出指定的库中所有表的非主键索引的删除语句，如： 将输出拷贝下来，过滤掉不需要删除的，将剩余的需要执行的语句拷贝到mysql控制台执行，就万事大吉啦。"},{"title":"Nginx中proxy_pass问题","date":"2019-06-24T14:22:08.000Z","url":"/20190624-2.html","tags":[["centos","/tags/centos/"],["nginx","/tags/nginx/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":"看到网上对于proxy_pass有很多分析， 有的分析写的很复杂，不便于快速学习和使用。所以写下自己的理解，力求简单。 proxy_pass其实可以看作简单的url替换，这个替换有两种： 当proxy_pass仅带有host和port时，仅仅替换host和port; 当proxy_pass带有path时（包括’/‘)，用指定的uri替换location所匹配的uri; 例如： nginx.conf中这样配置： 这里proxy_pass不带有path部分，则仅替换host和port; 如请求则替换为. 当proxy_pass带上path部分，如： 则会将请求替换为. 下面是更多例子： "},{"title":"CentOS7替换国内镜像源","date":"2019-06-24T12:22:08.000Z","url":"/20190624-1.html","tags":[["centos","/tags/centos/"],["镜像源","/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":"以中科大源为例： 1 先备份CentOS-Base.repo 2 建立新的repo文件 3 生成缓存"},{"title":"ubuntu中vscode导致卡顿问题解决","date":"2019-06-05T14:22:08.000Z","url":"/20190605-1.html","tags":[["ubuntu","/tags/ubuntu/"],["vscode","/tags/vscode/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":"vscode在ubuntu中体验和windows一样，感觉很好，只是偶尔在修改文件时会导致濒临卡死现象，几乎不能操作；网上查了下，与gpu硬件加速有关，gpu硬件加速需要消耗额外的内存资源，如果配置较低或者打开进程过多，容易导致内存耗尽而卡死。vscode默认启用gpu，这点可能是不必要的。 vscode 禁用GPU硬件加速的方式如下： 在打开的文件中两处地方加入 –disable-gpu： 这样操作后，问题就解决了。"},{"title":"C/C++内置类型，数值常量和隐式转换","date":"2019-05-25T14:22:08.000Z","url":"/20190525-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/tags/C-%E5%9F%BA%E7%A1%80/"],["内置类型","/tags/%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/"],["隐式转换","/tags/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E5%9F%BA%E7%A1%80/"]],"content":" 写这篇，一是想巩固下基础知识；二是发觉网上很多写的也是错漏较多，模糊了去查了看需要很多时间去分辨对错；故自己总结下，自觉应该不会出错吧(错了欢迎指出，我再纠正。)- -||| 一、C/C++内置类型长度我们知道C++内置类型有bool, char, short, int, long, long long, float, double, long double, wchar_t这些。每种类型的长度都不一样，但是C/C++标准并没有规定每个类型必须要占多少字节，而是规定了长度的最小值等一些约束。所以实际上各个类型的变量长度是由编译器来决定的。 那么编译器是根据什么来决定类型的长度呢？操作系统位数orCPU位数？ 我们知道这样一个关系： 32位编译器编译出来的是32位应用程序；64位编译器编译出来的是64位应用程序。 而这里编译器是32位or64位指的是利用该编译器生成的应用程序是32位or64位；与该编译器应用程序自身是32和64位的没有关系，也就是与操作系统是32位or64位没有绝对关系，同样与CPU位数也没有绝对关系。 比如在64位系统上的32位编译器，其应用本身可以是32位的也可以是64位的；同样的，理论上在32位系统上一样可以做出64位的编译器， 其应用本身是32位的，但是可以生成64位程序（只是32位的系统不能运行64位的应用程序）。 事实上，编译器依据一种数据模型来决定其类型的长度。这些数据模型有：ILP32, ILP32LL, LP64, LLP64, ILP64等。其中I,L,P分别指int,long, pointer (如ILP32LL与ILP32LL64等同，意为int，long，pointer为32位，longlong为64位）。其中各种模型中类型的长度区别为： 类型 ILP32 ILP32LL LLP64 LP64 ILP64 char 8 8 8 8 8 short 16 16 16 16 16 float 32 32 32 32 32 int 32 32 32 32 64 long 32 32 32 64 64 pointer 32 32 64 64 64 long long … 64 64 64 64 double 64 64 64 64 64 现如今，32位的windows程序的数据模型为ILP32LL；64位的Windows程序数据模型是LLP64；绝大部分Unix，linux编译器和应用程序都是使用的LP64模型。 二、数值常量的类型2.1 数值常量的表示方法C/C++的数字常量有这样几种表示：18, -23, 3., -5.4, 2E-2, 07, -036, 0x3a, -0xFF。 其中18, -23, 3., -5.4, 2.9E-2为10进制表示， 其中2.9E-2为科学计数法（10进制指数表示）；07, -036为8进制表示；0x3a, -0xFF为16进制表示。 其中18, -23, 07, -036, 0x3a, -0xFF皆为整数型常量；3., -5.4, 2E-2皆为浮点数型常量（小数型常量）。 从中我们可以总结出： 以0开头的为8进制常量，0后只能以数字0~7表示； 以0x开头的为16进制常量，其后只能以数字和字母0~F表示； 其他为10进制常量，整形不能以0和0x开头，只能以0~9和小数点表示； 8进制和16进制不能用来表示浮点数； 科学计数法表示的一定是浮点数 2.2 数值常量的类型和后缀C/C++数值常量后可以跟随一个后缀来给编译器指示类型；如果不加后缀，编译器会根据数值的范围指定合适的类型。 编译器自动选择： 如果是浮点型常量，则指定double类型； 如果是整数型常量，如果在int表示的范围内，则指定为int；如果超出int，对于正数，按照int-&gt;unsigned int-&gt;long-&gt;unsigned long-&gt;long long-&gt;unsigned long long的方向指定合适的类型；对于负数，按照int-&gt;long-&gt;long long的方向指定合适的类型。 指定后缀： 整数型后缀有U，L或其组合(UL, LL，ULL或LLU)；其中U,L不区分大小写，分别表示unsigned 和long；如ull和llu都表示unsigned long long。 小数型后缀有F, L。分别表示float，long double。即单精度浮点数和长双精度浮点数。 整数后接f，或者小数后接U都会报错。 三、隐式转换3.1 隐式转换场合C/C++在以下四种情况下会进行隐式转换: 算术运算式中，低类型能够转换为高类型。 赋值表达式中，右边表达式的值自动隐式转换为左边变量的类型，并赋值给他。 函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。 函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。 3.2 算数运算的隐式转换算数运算中，首先有如下类型转换规则： char和short先转换为int。 float型数据在运算时一律转换为双精度(double)型，以提高运算精度(同属于实型) 。 当不同类型的数据进行操作时，应当首先将其转换成相同的类型，然后进行操作，转换规则是由低级向高级转换。转换规则如下图所示: 算数表达式的值类型与参与运算的值类型相同。 四则运算中，特别要注意unsigned运算。实际编程中最好避免unsigned值参与运算。 举例： 四、64位编程应注意事项4.1 格式化字符串：long使用%ld，指针使用%p32位下，打印地址可以用%x，但在64位下只能打印低4位；所以64位应用%p。 4.2 64位下的对齐64位下，因为long和指针的长度可能发生了变化，所以32位下对齐良好的的结构可能变得不太好，导致32位程序在64位系统上运行性能下降。如： ILP32下,sizeof(A)=16; 但是在LP64下，sizeof(A)=32。"},{"title":"centos7搭建gitlab及初期设置","date":"2019-05-24T14:22:08.000Z","url":"/20190524-1.html","tags":[["centos","/tags/centos/"],["gitlab","/tags/gitlab/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":" 最近因为工作的原因，需要熟悉gitlab，就在自己的服务器上先建了一套了解一下，网上看了些教程操作下来基本没啥问题，只是很多文章都说的比较零散，故这里综合一下。 一、gitlab简介gitlab是一个类似于github的代码仓库管理系统。由GitLabInc.开发并开源，使用MIT许可证。gitlab各方面体验和github非常相似，因为开源，个人和公司都可以用来搭建自己的私有代码仓库管理系统，非常方便。 gitlab原先全部由ruby编写，后来部分功能用go进行重写。其Web框架使用RubyonRails，数据库采用PostgreSQL，用户认证和授权基于Gitolite，邮箱服务采用postfix。 gitlab内部嵌入式集成了许多linux上常见的应用和服务。比如nginx, unicorn, logrotate, redis等。所以一键安装会很方便。当然其体量也会比较大。 下面是我在自己的服务器上（4C8G）获取的一些数据： 从以上数据可以看到gitlab启动65个进程，占用内存接近4G。所以服务器要求还是比较高的。 二、gitlab安装2.1 配置yum源 接下来缓存相关包 2.2 安装相关依赖 2.3 安装gitlab 三、gitlab配置GitLab 的相关参数配置都存在 /etc/gitlab/gitlab.rb 文件里，每次配置完成之后需要执行gitlab-ctl reconfigure，进行重新配置才能生效。 3.1 基本配置主要调整下面一些参数： 3.2 邮箱配置gitlab可以通过SMTP服务给用户发送邮件，在/etc/gitlab/gitlab.rb文件中，邮箱有两处配置，一处是系统发件人配置，一处是邮箱的SMTP服务配置。 注意gitlab_email_from与smtp_user_name必须一致。 3.3 备份配置可修改备份文件存储路径，备份文件访问权限，备份加密方式，备份网络上传等。 3.4 配置完成重启gitlab对其相关的每个服务都提供了一系列配置，可以基于此优化性能。可以参考这个文章：解决gitlab内存消耗过大问题。另外gitlab还提供禁用内置nginx，接入外部nginx的配置方式。因为可能会遇到一些问题，我没有尝试，所以就不写了。 相关的配置完成后，必须重新运行gitlab-ctl reconfigure生成最终配置，并且需要重启gitlab： 四、gitlab常用命令 四、测试邮件和web服务4.1 测试邮件服务 4.2 测试web服务从浏览器访问上面配置的external_url。gitlab提供了一个初始账号。 初始账户: root 密码: 5iveL!fe 第一次登录会要求修改密码。 这样不出问题就完成了gitlab的部署，剩下的就是去网站摸索各种功能咯，祝玩的愉快o(∩_∩)o"},{"title":"mysql5.7升级到mysql8.0遇到的问题","date":"2019-05-20T14:22:08.000Z","url":"/20190520-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["mysql","/tags/mysql/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据库","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"content":"今天把博客迁移了服务器，顺便把mysql5.7升级到了mysql8.0，，过程还算顺利，mysql上只碰到了两个问题，记录一下。 一、登录问题mysql8.0建好后发觉navcat12登录不上去，提示ERROR 2059 (HY000): Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded。查了下发觉mysql又改变了登录认证方式。新的默认的登录是采用caching_sha2_password方式，而将原来的登录方式放到了mysql_native_password方式中。 mysql5.7中我们创建用户的语句是这样的： 在mysql8.0中这样创建的就是采用caching_sha2_password方式登录认证的用户，要在8.0中恢复原来的密码登录方式，需要将语句变为： 相应的，对于已经创建的用户，修改其登录方式和密码： 二、datetime问题将mysql5.7的结构和数据导入mysql8.0时，发生datetime默认值错误的问题。查看了下sql语句，datetime用的默认值是’0000-00-00 00:00:00’。感觉没啥问题啊，于是查了下，发觉mysql官网给了这么一段话： The DATE type is used for values with a date part but no time part. MySQL retrieves and displays DATE values in ‘YYYY-MM-DD’ format. The supported range is ‘1000-01-01’ to ‘9999-12-31’. The DATETIME type is used for values that contain both date and time parts. MySQL retrieves and displays DATETIME values in ‘YYYY-MM-DD hh:mm:ss’ format. The supported range is ‘1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’. The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP has a range of ‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC. datetime的默认值的起始时间设了限制，改为了’1000-01-01 00:00:00’（我也是醉了）。修改后再导入就OK了。"},{"title":"C++变量初始化详解(C++98和C++11)","date":"2019-05-17T14:22:08.000Z","url":"/20190517-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/tags/C-%E5%9F%BA%E7%A1%80/"],["变量初始化","/tags/%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E5%9F%BA%E7%A1%80/"]],"content":" 在C++11以前，C++的初始化基本上是在C的初始化方式基础上加上了类和类成员的初始化，有很多不太方便的地方。C++11一口气修改了大多数问题，但是也让初始化问题变得更复杂，所以我觉得有必要梳理一下。 C++98的变量初始化C++98的初始化大部分继承自C，也支持数组，struct和union复合类型利用{}初始化列表来初始化。需要注意的是，初始化列表是顺序初始化，即按照内存顺序一个一个初始化对应成员，这点在下面我们将会看到。 1、POD类型，指针，引用初始化: 可用=或者() 2、复合类型结构体和联合体初始化： 非堆上的对象(不是new出来的)，可用=形式的{}初始化列表和同类型对象初始化 堆上的对象(new出来的)，用空括号()初始化，括号不能传参 注意，复合类型结构体不能有类对象成员或构造函数；否则就成了类 3、类对象初始化： 可用=形式或者()形式，不可用{}初始化列表，其实都是调用构造函数或拷贝构造函数 成员变量通过构造函数初始化列表初始化；没有显式初始化的成员将不会被初始化 3、数组的初始化： 非堆上的数组(不是new出来的)，可用=形式的{}初始化列表，字符串数组可以直接用常量字符串初始化 堆上的数组(new出来的)，用空括号()初始化，括号不能传参 类对象数组的成员一定会调用构造函数初始化 4、复杂类型初始化 对于复杂类型，其自身和成员的初始化应满足以上规则和方式 C++11的变量初始化C++11在变量初始化上做了很大拓展，主要有这么两方面： 将初始化列表进一步完善成**统一初始化器(Uniform initialization)**； 类成员的原地初始化； 另外：初始化列表前的等号可以省略了。 1、统一初始化器统一初始化器依然保持初始化列表的形式，兼容C++98的用法。从上面C++98我们可以看到，原来的{}初始化列表不能用来初始化new出来的结构对象或数组，也不能用来初始化类对象。C++11中这两个弊端被解决。所以我们只需要了解下统一初始化器在这些地方的使用。 对于类对象来说，如果利用初始化列表来初始化： 如果类存在接受std::initializer_list参数的构造函数，则优先调用该构造函数； 如果类不存在接受std::initializer_list参数的构造函数，则调用参数个数和类型与初始化列表元素个数相等，类型相符的构造函数； 如果类中找不到以上两种匹配的构造函数则报错; 一个例外是，如果一个自定义类既有默认构造函数，也有std::initializer_list作为参数的构造函数，则使用{}作为初始化值构造对象的话，C++标准显式规定了调用其默认构造函数，如果想要以空列表的语义调用第二个版本，则可以使用({})的方式进行初始化。 另外，以std::initializer_list作为形参的话，其实参列表中的元素不要求和T完全匹配，而只需要能转换成T即可，此时只要转换后满足要求，编译器都会优先使用std::initializer_list作为形参的重载版本。在转换的过程中，如果类型提升满足要求则会正常调用；如果发生了窄化转换，则调用会失败报错；只有诸如字符串和数字这类无法转换的类型相互重载时候，重载机制才可能正常工作。 2、类成员就地初始化在C++11之前，只能对结构体或类的静态常量成员进行就地初始化。在C++11中，结构体和类的数据成员在申明时可以直接赋予一个默认值，初始化的方式有两种，一是使用等号&quot;=&quot;，二是使用{}列表初始化。 C++11标准支持了就地初始化非静态数据成员的同时，构造函数初始化列表的方式也被保留下来，也就是说既可以使用就地初始化，也可以使用初始化列表来完成数据成员的初始化工作。当二者同时使用时，并不冲突，初始化列表发生在就地初始化之后，即最终的初始化结果以构造函数初始化列表为准。参考如下代码： 一些需要注意的问题C++11的初始化确实给我们带来了许多方便，不过有些情况的存在，也很容易让我们忽视和误解，这里举一些例子。 比如对于vector变量定义，有这么两种形式： 用auto定义的变量： "},{"title":"2019四月新番推荐和点评","date":"2019-05-12T15:42:26.000Z","url":"/20190512-18.html","tags":[["ACGN","/tags/ACGN/"],["动漫推荐","/tags/%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90/"]],"categories":[["ACGN","/categories/ACGN/"]],"content":" 2019四月番对于ACGer来说，实在是一次异常丰盛的盛宴。很多以前广受好评的番都在四月出了续集，也有不少优质轻改和漫改，简直有点看不过来。笔者没有全部去看，仅仅试看了部分，挑选了一些符合自己口味的番在追着，回味着那份不变的热血和感动。对于自己觉得特别优质的番时，总想全部保存起来，待到将来看无可看时，再拿出来回味。 鬼灭之刃这个是我最想安利的番，就网上的各种介绍和排行来看，该作严重被低估，所以放在第一个介绍。估计许多人看到这个名字，都会下意识觉得这是一个平庸的番；确实这个名字不咋地，但是这个番确实地地道道的良心大作。画风，剧情，人物刻画无一不是上上之品。就目前播出的前五集来看，有成为经典神作的潜质。这部作品让我想起了《犬夜叉》，虽然风格并不类似，但是内含着一样的认真。 故事讲述日本大正时期，住在山上的卖炭少年炭治郎，和母亲以及五个弟弟妹妹相依为生。但是在一天下山卖炭期间，母亲和四个弟弟妹妹被恶鬼残杀，唯一幸存的妹妹祢豆子因伤口染鬼血也变成了鬼，炭治郎因天晚在山下留住一宿而逃过一劫。炭治郎唤醒了妹妹的一丝理智，立志寻找让妹妹恢复人身的方法，在猎鬼者的帮助下，炭治郎通过了艰苦的训练，踏上了猎杀恶鬼和拯救妹妹的道路。 最深刻的悲剧述说着最真切的情感，少年炭治郎的坚强和善良却让世间的悲伤充满着感动和希望。这是一部能够让人感动和铭记的番作。惯例放几张图感受下： 一拳超人 第二季一拳超人又叫一击男，第一部已经奠定了神作的地位。这是一部一开始主角无敌的番，然而和《overlord》骨傲天一样，无敌但不轻浮，一样的认真对待生活和他人。从这些无敌的主角的性格和对待生活的态度中，我们可以从另一个角度去看待和思考人性和人生，也能够获得很多的认知和感悟。 不要小看这线条简单的光头，他的实力或许并不比龙珠悟空弱。 灵能百分百 第二季这个其实是一月番，但是一月没有做总结，放这里算了。这部和一拳超人是一个作者的作品，而且都是主角无敌的动漫，一样的神作。就不放图了。 贤者之孙这个其实也是主角无敌的番，不过走的是校园和魔法的路子，值得一看。 盾之勇者成名录这个其实也是一月番，不过篇幅比较长，延续到四月。异世界英雄冒险故事，值得一看。 多罗罗同上一月番，这部感觉比较沉重，主角出生被亲生父母献祭并抛弃，被鬼神夺取了四肢，器官和五感，但是顽强生存并逆袭。因为时间原因，没有太认真看，但是是部好番，值得推荐。 以上基本上都可以归到热血番里面，其他类型的应该也有不少好番，不过可能笔者年纪大了，对青春恋爱番已经提不起兴趣，没怎么看，就不推荐了。"},{"title":"php-fpm介绍，配置和优化","date":"2019-05-12T15:41:04.000Z","url":"/20190512-17.html","tags":[["php基础","/tags/php%E5%9F%BA%E7%A1%80/"],["php-fpm","/tags/php-fpm/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"]],"content":" 上个月把博客站从php5.5.7升级到了php7.3.4，一个月的时间已经发生多次服务器卡死的情况，之前顾不上深究，直接重启了事。今天抽点时间处理了下，顺便把相关的知识点记录下来。 一、php-fpm 介绍虽然对php不熟，但是本着虽不求甚解，但不能不了解的思想，所以我还是去阅读了一些php-fpm的相关知识。php-fpm是php-fastcgi process manager的简称。所以了解php-fpm不得不稍微了解下fastcgi以及cgi的相关知识。下面是一些笔者觉得不错的参考文章： 动态web技术(二) — CGI FastCGI协议详解及代码实现 nginx、php-fpm、fastcgi深入理解与优化 其实看了许多文章，但是对比理解发觉，许多文章描述有误或语焉不详，比如对于nginx的fastcgi和php的fastcgi的关系，这里我稍微总结梳理下： cgi: 对接标准输入和标准输出的程序，其实现与语言无关。HTTP服务器每次收到请求后，启动一个CGI进程并将请求传入，CGI进程完成后退出。这种fork-and-execute模式导致性能低下。 php-cgi: 包含php解释器的CGI程序（不是用php写的CGI程序），能够处理php请求。 fastcgi：一种用于更好的提供CGI功能的协议；fastcgi协议采用C/S结构，http服务器只需要包含fastcgi的C端模块，通过socket与支持fastcgi S端的CGI程序通信。这样既解决了CGI反复加载的问题，又可以将CGI程序和http服务器分离。nginx的fastcgi模块即fastcgi的C端。 php-fpm: 包含php解释器，实现了fastcgi的S端，并且提供了进程管理功能的程序。可以常驻内存并持续接受和处理php请求，并且能够控制进程的数量和生存周期。 二、php-fpm 配置和优化php-fpm一直存在一些固有问题，如内存泄漏，进程僵死等；这些问题会导致占用内存一直增加，进程数不停增加，直到服务器资源耗尽死机。所以php-fpm的配置主要是围绕控制进程数和进程生命周期进行的（用这种方法来解决性能问题不得不说php团队也是对这个语言的没辙了）。 php中主要有这么两个配置文件：php.ini, php-fpm.conf; 前者是php解释器的配置，后者是php-fpm的配置。php的性能优化主要是调整进程管理相关参数即php-fpm.conf。 这里列举一些重要的配置，并做一些说明： 额外说明： emergency_restart功能，process_control_timeout和 slowlog功能默认都是关闭的，若有频繁假死，进程过多，死机等情况，建议都打开。 进程的数量要根据服务器的实际情况调整，不然也会耗尽资源。比如，每个php-fpm占用内存一般在30M到50M之间，对于1G内存的服务器，可能不到30个就会耗尽内存，所以可以设置： 其实也不确定这样是否能高枕无忧，观察一段时间再看。对于解决不了的，网上还有一种终极大法：利用linux定时器任务执行脚本(或者后台持续运行脚本)，在脚本中监测php-fpm的进程数量或系统内存占用，达到条件重启php-fpm，简单有效。 一个根据memory重启的例子: checkmem.sh 后台启动： "},{"title":"为你的博客博客/网页添加Live2d二次元老婆的插件/手动方法","date":"2019-05-12T15:39:18.000Z","url":"/20190512-16.html","tags":[["博客","/tags/%E5%8D%9A%E5%AE%A2/"],["wordpress","/tags/wordpress/"],["live2d","/tags/live2d/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"],["博客","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2/"]],"content":" 今天抽空给博客添加了个live2d角色，将看到的比较好的一篇教程放到这儿。 前言好久没搞WP的教程了，想不想为你的博客加一个看板娘呢，反正我想2333，所以我便汇总了一下网上这些教程模型和机器人api。 ![](/images/2019/05/live2ddemo.png) 插件版WordPress Wikimoe大佬制作的插件（伊斯特瓦尔） 小白-白大佬制作的插件（22&amp;33娘单服装版本） Github 小白-白大佬制作的插件（22&amp;33娘可换装版本） Github Typecho Wikimoe大佬制作的插件（伊斯特瓦尔&amp;蕾姆） 泽泽大佬制作的插件（22&amp;33娘） DaiDR大佬制作的插件（Pio） 保罗大佬制作的插件（Pio） Emlog Wikimoe大佬制作的插件（伊斯特瓦尔） ZBlog FGHRSH大佬制作的插件（Pio&amp;Tia） 手动搭建 还是感觉手动搭建比较有感觉。。 首先先下载模型，模型在后面有，重命名为live2d后上传到网站的根目录（试过将live2d放到主题目录，自动加载模型时可能会有路径问题，要改一下） 在网站的header中的head标签内加入如下代码 在页面的body标签内找到合适的位置插入 Live2D 看板娘的元素（不同模型可能有些细微差异，一般下载的live2d model带有readme或demo，注意看说明） 上面的音乐地址填上音乐文件（mp3）的url；可以放多个音乐；如 在页面的 body 标签结束前插入如下代码(引入过jquery不用重复引入，但是要保证其他script在jquery之后)： 对于Wordpress来说把4,5两步的代码加到主题目录下footer.php中body标签内即可。 加入图灵机器人 为了让live2d能够聊天，我们可以借助图灵机器人，先去图灵机器人官网注册账号，新建机器人获取apikey。 新建一个talkapi.php文件，加入如下代码，注意添加自己的apikey到里面。 将talkapi.php上传到网站根目录，在footer中把添加的talkAPI的值设为talkapi.php相对根目录的路径即可。 模型下载整理了一些：加藤惠，纱雾，康纳，真白，伊斯特瓦尔，蕾姆等。  感谢感谢以上插件制作的博主。 夏晨博客及维基萌整理的模型和图灵API教程。"},{"title":"linux之cron服务","date":"2019-05-12T15:38:09.000Z","url":"/20190512-15.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["cron","/tags/cron/"],["crontab","/tags/crontab/"],["anacron","/tags/anacron/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":"在Linux中，如果要在预设时间执行shell脚本，at命令非常好用，但如果需要定期执行shell任务，例如每天一次、每周一次，则需要Linux的cron程序来安排定期执行的作业。 一、cron服务简介linux中cron服务相关的程序有：crond, crontab, anacron。 crond是linux中一个用来周期性的执行任务的守护进程。绝大多数linux发行版都带有crond服务，并随系统自动启动。crond服务以每分钟一次的频率检查配置文件，并且在固定的时间点执行任务。 crontab是与crond一起的命令程序；用户可以通过crontab设置cron时间表来维护自定义的cron任务。 anacron 是crond与crontab的延伸程序。用于以天为单位的频率执行任务。 anacron并不是一个服务程序，它的周期性执行依赖于crond服务中对于anacron的配置。centos中，anacron每小时会被检查执行一次。 anacron任务格式不设置具体时间点，而是设置任务的时间周期(单位：天）和延迟（单位：分钟），只要检查时当前时间距离上次执行时间点超过设置周期，那么任务在机器运行时都会执行一次。 例如，假设你有一个计划任务设置在每天半夜运行，如果用crontab配置，假如笔记本电脑晚上关机，第二天早上开机，那么该任务就会错过一次执行；如果使用 anacron，那么在第二天开机时，anacron判断满足时间间隔，就会执行一次。 二、crond 和 crontab2.1 安装cron服务若是cron服务没有安装（现在一般linux系统都自带了），则可以通过yum等包管理器安装： 2.2 cron服务相关文件和目录（centos7）：应用程序和系统文件：（删除线表示不太需要关注） /usr/lib/systemd/system/crond.service: 系统内置crond服务启动文件。 /usr/sbin/crond: crond服务主程序，在crond.service中配置。 /etc/sysconfig/crond: crond服务的系统配置程序，用户不应修改。 /usr/bin/crontab：crontab命令程序 配置文件和目录： /etc/crontab：系统级crontab任务配置文件。 /var/spool/cron/：用户级crontab任务配置文件目录；其中的文件需以用户名来命名。如果存在非用户名文件(如任意文件fasdfa)，则cron会每分钟报错：crond[3950]: (fasdfa) ORPHAN (no passwd entry)。 /etc/cron.d/: 相当于/etc/crontab文件的扩展目录，存放系统级crontab任务配置文件。 /etc/cron.hourly: 系统内置的按小时执行的任务目录，存放按小时执行的脚本。该目录配置在/etc/cron.d/0hourly文件中。 /etc/cron.daily|/etc/cron.weekly|/etc/cron.monthly：系统内置的按日|周|月执行的任务目录，存放按照相应时间周期执行的脚本。这些目录配置在/etc/anacrontab文件中，由anacron保证其功能。 权限配置和日志文件： /etc/cron.allow：将可以使用 crontab 的帐号写入其中，不在该文件内的用户不可使用 crontab。 /etc/cron.deny：将不可以使用 crontab 的帐号写入其中，不在其中的使用者可以使用 crontab。 如果allow和deny文件都不存在，则只有root用户可以使用crontab命令。若都存在，allow文件优先于deny文件。一般来说，只需要保留一个，系统预设是保留 /etc/cron.deny ，你可以将不想让他执行 crontab 的使用者写入 /etc/cron.deny 当中。 /var/log/cron：cron日志文件。 2.3 crontab文件格式crontab 每一行都代表一项任务, 每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下： field allowed values minute 0-59 hour 0-23 day 1-31 month 1-12 (or names) week 0-7 (0 or 7 is Sunday, or use names) 通过空格或tab分割；时间用数字或通配符表示； 支持范围表示：8-10表示8,9,10 支持列表：1,2,5,9 支持间隔：*/2，在hour位表示每隔两小时 月和星期可以使用英文的前三个字母表示，但这种形式不支持范围和列表。 例如，如果要在每天10:15运行命令: 又例如，每隔7天，凌晨3点整自动执行命令： 补充说明： 1）在command命令之前，还可以加上用户名；还可以通过run-parts参数指定命令文件目录。格式为： 用法举例： 2）在/etc/crontab文件中，可以指定不同的用户名；在/var/spool/cron/目录下的文件中，只能指定与文件名相同的用户，指定其他用户的任务无效。 2.4 crontab命令命令格式: 命令功能： 设置用户的cron任务。创建、编辑和删除用户级别的cron配置文件。 参数说明： -u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。 file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。 -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。 -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。 -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。 -i：在删除用户的crontab文件时给确认提示。 使用说明： 不建议直接编辑/var/spool/cron下面的文件，避免造成安全问题和误操作。可以先在用户目录下编辑一个crontab格式的文件，然后使用crontab file的方式载入。这样也可以给crontab任务留存一个备份，在crontab文件丢失时，可以方便的恢复。 2.5 注意事项2.5.1 环境变量问题有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。 在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。 不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点： 脚本中涉及文件路径时写全局路径； 脚本执行要用到额外环境变量（如java相关）时，通过source命令引入环境变量；如： 当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如： 2.5.2 注意清理系统用户的邮件日志每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。例如，可以在crontab文件中设置如下形式，忽略日志输出： /dev/null 2&gt;&amp;1表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。 2.5.3 系统级任务调度与用户级任务调度系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。 2.5.4 其他 在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date +%Y%m%d在crontab里是不会执行的，应该换成date +\\%Y\\%m\\%d。 三、anacronanacron每小时执行一次，其运行脚本文件为：/etc/cron.hourly/0anacron。可见anacron正是依赖crontab每小时任务来保证其周期执行的。 应用程序和系统文件：（删除线表示不太需要关注） ~~`/usr/sbin/anacron`：anacron执行程序 配置文件和目录： /etc/cron.hourly/0anacron：anacron运行脚本。 /etc/anacrontab：anacron任务配置文件。 /var/spool/anacron/：与crontab中的配置意义不同，该目录由anacron自动维护，其下的文件名称是anacron的任务名称，记录最近一次执行anacron任务的时间戳（日期）。anacron每小时检查这些时间戳以确定是否执行任务。 3.1 anacron时间格式anacron任务配置格式如下： field allowed values duration 任务周期，数字，单位：天 delay 任务延迟时间，数字，单位：分钟 以/etc/anacrontab中的默认配置为例： 四、总结crontab和anacron中的目录依赖关系比较复杂，现总结如下： crond 每分钟主动读取 /etc/crontab, /etc/cron.d/, /var/spool/cron/ 等配置，并依据【分，时，日，周，月】的任务时间设置去执行任务； 根据 /etc/cron.d/0hourly 的设置，主动读取并执行 /etc/cron.hourly/ 目录下的脚本； 根据 /etc/cron.hourly/0anacron 的设置，主动每小时执行一次anacron ，anacron会读取 /etc/anacrontab 的配置； 根据 /etc/anacrontab 的设置，主动依据每天、每周、每月去分析和执行/etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/ 內的脚本。 更多可以参考：鳥哥的 Linux 私房菜 – 第十五章、例行性工作排程(crontab)"},{"title":"C++ union介绍","date":"2019-05-12T15:35:51.000Z","url":"/20190512-14.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/tags/C-%E5%9F%BA%E7%A1%80/"],["C++类型","/tags/C-%E7%B1%BB%E5%9E%8B/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E5%9F%BA%E7%A1%80/"]],"content":"union的定义和特性C++union是继承自C的复合类型，和C语言中的union定义保持一致。union具有以下特点： union中所有成员共享同一段内存，所有成员起始地址相同； union的长度由最大长度的成员与类型长度最大的成员共同决定，其长度是类型长度最大的成员长度的整数倍； union的成员只能是内置类型和除引用外的复合类型； union不可以有静态成员。 union的长度上面第二点描述了union的长度，理解起来可能有点绕，来看下面的例子： sizeof(U)的值必须不小于sizeof(char[10])，且是其类型长度最大成员d的长度的整数倍，在32位下，sizeof(double) == 8，所以，sizeof(U) == 16。 union的成员类型对于以上第三点，需要注意C++中的struct对于C语言struct的改变。C++中的struct可以用来定义C式结构体和类类型（class也一样）【C++内置类型和复合类型】。看下例代码： 上面的代码编译器会报错： 如果将class A的默认构造函数去除，则没有问题。 union的使用union常用于测试CPU大小端问题。如下代码： 总结C++ union的使用应保持和C语言一致，应注意避免C++语言特性带来的隐性改变。"},{"title":"C++ 默认构造函数","date":"2019-05-12T15:32:43.000Z","url":"/20190512-13.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/tags/C-%E5%9F%BA%E7%A1%80/"],["默认构造函数","/tags/%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E5%9F%BA%E7%A1%80/"]],"content":"C++默认构造函数是可以不用实参进行调用的构造函数，它包括了以下两种情况： 没有带明显形参的构造函数。 提供了默认实参的构造函数。 我们知道，在类设计者没有提供默认构造函数的情况下，编译器会帮我们自动合成默认构造函数。但是这里面的理解，很多人包括我曾经有两点误解： 类如果没有定义任何的构造函数，那么编译器一定会为类定义一个合成的默认构造函数。(错误！) 合成默认构造函数会初始化类中所有的数据成员。（错误！） 一些书中对这里面的解释也是语焉不详，或者翻译的不够准确。事实上需要强调的是： C++编译器只有在必要时才给类合成默认构造函数。 合成默认构造函数总是不会初始化类的内置类型及复合类型的数据成员。（关于内置类型和复合类型见：C++ 类型） 编译器在这么几种情况下会给类添加默认构造函数： 1. 含有类对象成员，且该成员类型有默认构造函数。如果一个类没有任何构造函数，但是它含有一个类对象成员，且该成员类型有默认构造函数，那么编译器就会为该类合成一个默认构造函数，不过这个合成操作只有在构造函数真正需要被调用的时候才会发生。 举个例子，编译器将为类A合成一个默认构造函数： 合成的默认构造函数代码大概如下： 被合成的默认构造函数内只含必要的代码，它完成了对数据成员s的初始化，但不产生任何代码来初始化A::v。正如上面所述，初始化类的内置类型或复合类型成员不是编译器的责任。如果类中有多种类对象成员，则编译器按照这些类对象成员声明的顺序，在构造函数按顺序插入调用各个类默认构造函数的代码。 2. 基类带有默认构造函数的派生类。当一个类派生自一个含有默认构造函数的基类时，该类也符合编译器需要合成默认构造函数的条件。编译器合成的默认构造函数将根据基类声明顺序调用上层的基类默认构造函数。如果设计者定义了多个构造函数，编译器将不会重新定义一个合成默认构造函数，而是把合成默认构造函数的内容插入到每一个构造函数中去。 3. 带有虚函数的类类带有虚函数可以分为两种情况： 类本身定义了自己的虚函数。 类从基类中继承了虚函数。 带有虚函数的类也满足编译器需要合成默认构造函数的条件。原因是含有虚函数的类对象都含有一个虚表指针vptr，编译器需要对vptr设置初值以满足虚函数机制的正确运行，编译器会把这个设置初值的操作放在默认构造函数中。如果类设计者没有定义任何一个默认构造函数，则编译器会合成一个默认构造函数完成上述操作，否则，编译器将在每一个构造函数中插入代码来完成相同的事情。 4. 虚继承的派生类虚继承是为了解决多重继承下确保子类对象中继承自每个父类的成员只存在一个副本的问题，考虑典型的菱形继承，如下图： 上图中菱形继承的虚继承代码如下： 对于虚继承，编译器将给每个虚继承的子类产生一个指向虚基类的指针；当虚继承的类被当做父类继承时，虚基类指针也会被继承。这个指针的安插，编译器将会在合成默认构造函数中完成。同样的，如果类设计者已经定义了多个构造函数，那么编译器不会重新写默认构造函数，而是把虚基类指针的安插代码插入已有的构造函数中。 总结 C++编译器只有在必要时才给类合成默认构造函数。 合成默认构造函数总是不会初始化类的内置类型及复合类型的数据成员。 编译器添加默认构造函数的必要情形可以概括为：a) 调用对象成员或基类的默认构造函数。b) 为对象初始化虚表指针与虚基类指针。 "},{"title":"C++类型：内置类型，复合类型和类类型","date":"2019-05-12T15:31:39.000Z","url":"/20190512-12.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/tags/C-%E5%9F%BA%E7%A1%80/"],["C++类型","/tags/C-%E7%B1%BB%E5%9E%8B/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E5%9F%BA%E7%A1%80/"]],"content":"如标题所言，C++类型基本分为三类：内置类型，复合类型和类类型。 内置类型：编译器内置的基本类型，如int, char, float, double, bool等； 复合类型：根据其它类型定义的类型，主要有这么几类：数组，字符串，指针，引用，结构体(struct)，联合体(union)； 类类型：用struct和class定义的类。 这里需要注意这么两点： 复合类型的字符串指的是C-style字符串，本质就是char数组。STL的string类是类类型。 复合类型的结构体指的也是c-style的结构体，和类型类一样，也是用struct和class定义；和类类型的区别是，没有构造函数（包括默认构造函数）和析构函数。 比如下例： 其中只有A是复合类型结构体，B和C都是类类型；B因为有显式定义默认构造函数；C因为有类成员，编译器会合成默认构造函数。 区别struct和class是复合类型结构体还是类类型是有意义的。 C++中复合类型结构体变量可以直接用初始化列表赋值，而类对象不行： 上例如果给struct A加上构造函数，则编译错误。 对于union类型，其成员就只能包含复合类型结构体，而不能有类类型。详情见：C++ union介绍。 "},{"title":"表达式树及其实现","date":"2019-05-12T15:29:59.000Z","url":"/20190512-11.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["表达式树","/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"]],"content":"表达式树介绍对于数学运算来说，其本质是一个分层的递归结构。每一步计算都是一个操作符作用于相应操作对象， 其操作对象又可以是一个操作数或任意复杂的表达式。而树的递归结构正好用来表示这种表达式。 对于二元运算来说，可以很自然的联系到二叉树：以操作数(operand)作为叶节点，以操作符(operator)为其他节点，其中操作符的左右孩子是它的左右运算对象。以算数表达式(3+2*9)-6/4为例，其转换为表达式树如下图所示： 二叉表达式树是最简单的情况，对于有三元或多元运算的情形，表达式树的节点会有多于两个孩子，即度大于3。这里我们只讨论二叉表达式树。 表达式树在常用于编译器设计中，作为对表达式进行语法分析的工具，能够对表达式进行有效的语法判断和求值。比如C#中的lamda表达式。 表达式树的创建表达式树可以从输入表达式来创建。其中最简单的实现是通过后缀表达式来创建。其方法与计算后缀表达式结果类似： 利用栈存放叶子节点和子树，记栈为S1； 从左往右扫描后缀表达式，当读到一个操作数时，将其化为节点压入栈S1中； 当读到一个操作符时，将操作符化为节点作根，从栈中弹出两个节点作为左右孩子，生成子树并将子树根节点压入栈中； 当扫描完成，栈中剩下唯一一个节点就是表达式树的根。 表达式树的求值表达式树利用递归，可以很自然的得出表达式的值。 表达式树的遍历观察表达式树，我们可以很容易发现，对表达式树进行前序，中序，后序遍历，我们分别可以得到前缀，中缀，后缀表达式。 其中需要注意的差别仅在于二叉树表示中消除了括号。在中序遍历时需要将生成的中缀表达式加上括号：当根结点运算符优先级高于左子树或右子树根结点运算符时，相应左或右子树前就需要加括号。 示例代码如下： "},{"title":"二叉树遍历（前序、中序、后序、层次、深度优先、广度优先遍历）","date":"2019-05-12T15:28:46.000Z","url":"/20190512-10.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["二叉树遍历","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"]],"content":"1. 基本概念 二叉树基础 树的遍历在实际使用中有非常重要的作用。对于二叉树来说，遍历可以分为深度优先和广度优先；其中深度优先可分为前序，中序，后序遍历；广度优先即层次遍历。 由于树的定义本身就是递归定义，因此采用递归的方法去实现树的前序，中序，后序三种遍历不仅容易理解而且代码简洁；而对于广度遍历来说，则须要其他数据结构如队列的辅助。 2 四种遍历详解四种基本的遍历思想为： 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树 中序遍历：左子树—&gt; 根结点 —&gt; 右子树 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点 层次遍历：按层次逐层遍历即可 2.1 前序遍历依据上文提到的遍历思路：根结点 —&gt; 左子树 —&gt; 右子树，前序遍历的递归形式非常容易给出： 如果考虑前序遍历的非递归形式，则考虑对任意节点，访问该节点后，先访问其左子树，之后再访问右子树；则在访问左子树时需要将该节点暂存；需要的用到的数据结构是栈。示例代码如下： 2.2 中序遍历依据上文提到的遍历思路：左子树 —&gt; 根结点 —&gt; 右子树，中序遍历的递归形式也非常容易给出： 非递归形式的中序遍历和前序类似，只是将访问节点放到了出栈后；即对于任意节点，先将其入栈暂存，再访问其左子树，然后出栈时先访问该节点，再访问右子树。示例代码如下： 2.3 后序遍历依据上文提到的遍历思路：左子树 —&gt; 右子树 —&gt; 根结点，后序遍历的递归形式也很简单： 后序遍历的非递归实现是三种遍历方式中最难的一种。对任意节点P，为保证访问顺序，需要对将节点P，右孩子，左孩子按顺序入栈；假设先将节点P入栈，对于任意栈顶节点P，假设P不存在子节点，则能够直接訪问它；若是P存在子节点，但是其子节点都已被訪问过了，则也能够直接訪问该结点；若非上述两种情况，则将P的右孩子和左孩子依次入栈。这样就保证了后序遍历的顺序访问节点。 2.4 层序遍历借助队列数据结构，层次遍历的实现比較简单。先在队列中增加根结点，之后对于出队的任意节点，先访问它，同时若有子节点，则将子节点入队列。 "},{"title":"二叉查找树和AVL树","date":"2019-05-12T15:27:24.000Z","url":"/20190512-9.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"],["二叉查找树","/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"],["AVL树","/tags/AVL%E6%A0%91/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"]],"content":"知识准备二叉树基础请见：二叉树基础 1 二叉查找树二叉查找树又称二叉搜索树（Binary Search Tree）或二叉排序树（Binary Sort Tree）。其或者是一棵空树，或者是具有下列性质的二叉树： 1 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；2 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；3 左、右子树也分别为二叉排序树；4 没有键值相等的节点（no duplicate nodes）。 **二叉查找树的平均深度是O(logN)**，所以查询速度是非常快的，实际使用也非常多。但是从定义我们可以知道，二叉查找树可以任意地构造，同样是上图六个数字，也可以按照下图的方式来构造： 这样这棵二叉树的查询效率就变得很低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树。 2 平衡二叉树（AVL树）平衡二叉树（AVL树）是在符合二叉查找树的条件下，还满足如下性质的二叉树： 任何节点的两个子树的高度最大差为1。 下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差&lt;=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1。 如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。它们的示意图如下： AVL树失去平衡之后，可以通过旋转使其恢复平衡。下面分别介绍四种失去平衡的情况下对应的旋转方法。 LL旋转LL失去平衡的情况下，可以通过一次旋转让AVL树恢复平衡。步骤如下： 将根节点的左孩子作为新根节点。 将新根节点的右孩子作为原根节点的左孩子。 将原根节点作为新根节点的右孩子。 LL旋转示意图如下： RR旋转RR失去平衡的情况下，可以通过一次旋转让AVL树恢复平衡，旋转方法与LL旋转对称。步骤如下： 将根节点的右孩子作为新根节点。 将新根节点的左孩子作为原根节点的右孩子。 将原根节点作为新根节点的左孩子。 RR旋转示意图如下： LR旋转LR失去平衡的情况下，需要进行两次旋转。步骤如下： 围绕根节点的左孩子进行RR旋转。 围绕根节点进行LL旋转。 LR旋转示意图如下： RL旋转RL失去平衡的情况下也需要进行两次旋转，旋转方法与LR旋转对称。步骤如下： 围绕根节点的右孩子进行LL旋转。 围绕根节点进行RR旋转。 RL旋转示意图如下： 从这四种旋转可以看出，首先我们应该判断失去平衡的树是LL、RR、LR、RL，然后针对性的进行旋转，然后就可以重新把树转化成平衡树。 平衡二叉树和avl树的C++示例代码如下： "},{"title":"二叉树概念基础","date":"2019-05-12T15:26:07.000Z","url":"/20190512-8.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"],["二叉树","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"]],"content":"1 树的介绍1.1 树的定义树是一种数据结构，定义树的一种自然方式是递归法。一颗树是由一些节点组成的具有层次关系的集合。若集合为空集，则称为空树；若不是空集，则树由一个称作 根(root) 的节点r与零个或多个非空子树组成；每个子树的根都与根节点r由一条有向 边(edge) 相连接。子树的根称为根节点r的“儿子(child)**”，而根节点r称为子树的根的“父亲(parent)**”。 1.2 树的基本术语 **叶子节点(leaf node)**：度为零的结点。 **分支结点(branch node)**：度不为零的结点。 **结点的度(degree of node)**：结点拥有的子树的数目。 **树的度(degree of tree)**：树中结点的最大的度。 **节点的层次(level of node)**：根结点的层次为1，其余结点的层次等于父结点的层次加1。 **路径(path)**：节点n1,n2,…,nk的一个序列，其中对于1&lt;=i&lt;=k,节点ni是ni+1的的父亲，则该序列成为节点n1到nk的路径。 **路径的长(length of path)**：路径上边的条数。 **节点的深度(depth of node)**：从根节点到节点ni的路径的长。因此，根节点深度为0。 **树的深度(depth of tree)**：最深的树叶的深度。 **节点的高度(height of node)**：从节点ni到一片叶子的最长路径长。因此，叶子节点的高度为0。 **树的高度(height of tree)**：根节点的高度。因此，一棵树的深度和高度总是相等。 2 二叉树介绍2.1 二叉树的定义二叉树是每个节点最多有两个子树的树。从定义可知，二叉树是度等于2的树。二叉树有五种基本形态：空集；仅有根；仅有根和左子树；仅有根右子树；有根和左右子树。 2.2 二叉树的性质二叉树有以下几个性质： 二叉树第i层上的结点数目最多为 2i-1 (i≥1)。 深度为k的二叉树至多有2k-1个结点(k≥1)。 包含n个结点的二叉树的高度至少为log2 (n+1)。 在任意一棵二叉树中，若叶子结点的个数为n0，度为2的结点数为n2，则n0=n2+1。 2.3 满二叉树定义：高度为h，并且由2h –1个结点的二叉树，被称为满二叉树。即节点数达到了二叉树能够拥有的最大数的二叉树。 2.4 完全二叉树定义：深度为h，除第h层外，其它各层(1～h-1)的结点数都达到最大个数，且第h层所有的结点都连续集中在最左边，被称为完全二叉树。完全二叉树是对满二叉树的补充，所有满二叉树都是完全二叉树。"},{"title":"抽象数据类型ADT","date":"2019-05-12T15:24:42.000Z","url":"/20190512-7.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"],["抽象数据类型","/tags/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"]],"content":"一、数据结构和数据类型在编程学习中，数据结构和数据类型是两个基本的专有名词。其含义相关而不同，也偶尔会让人产生一些迷惑。下面通过其定义来理解其中的区别和联系。 数据结构的定义如下： 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 数据结构大体有两种分类方式：逻辑结构和存储结构。按照逻辑结构可分为线性结构（如数组，链表等）和非线性结构（如树，图等），按照存储结构分为顺序存储结构，链式存储结构，索引存储结构和散列存储结构。 再来看看数据类型： 数据类型是一组性质相同的值的集合以及定义在这个值集合上的一组操作的总称。 数据类型是一种数学上的抽象概念，又称为抽象数据类型（abstract data type, ADT），其定义仅仅取决于它的逻辑特性，而与它在计算机中的表示和实现无关。比如对于map数据类型，其定义由其上定义的insert, delete, find, size等这些操作决定；而其底层实现可以是不同的数据结构。 按其值的不同特性，数据类型通常可以分为原子类型和结构类型。原子类型是指其值不可分解为其他类型的基础数据类型，以及其上定义的一组操作，如int, float, bool，char等；结构类型是指一种数据结构以及定义在这种结构上的一组操作。 从以上概念我们可以看出，数据结构和算法是实现抽象数据类型的方法。我们学习数据结构和算法，其实就是学习抽象数据类型的实现方法以及其应用。 二、经典数据结构和经典抽象数据类型在计算机语言的发展和应用过程中，人们已经研究和总结出了许多经典的抽象数据类型及其实现方法。C++标准库STL中也有了各种ADT的实现。 表ADT(table) : 大小为N,形如A1,A2,…AN的值集合。STL实现为&lt;vector&gt;,&lt;list&gt;,&lt;array&gt;和&lt;forward_list&gt;。 栈ADT(stack) ：栈是限制插入和删除只能在末端进行的表，该末端称为栈顶。栈的特点是后进先出（LIFO）。STL实现为&lt;stack&gt;。栈的应用可见：后缀表达式 队列ADT(queue) ：队列是限制只能在一端插入，在另一端删除的表。队列的特点是先进先出（FIFO）。STL实现为&lt;queue&gt;和&lt;deque&gt;。 树(tree) ：树是一种抽象数据结构，由一个根节点与零到多个子树相连而形成的节点的集合。经典的树类数据结构有 二叉查找树，AVL树，红黑树，B/B+树等。STL中依据二叉树实现的ADT为&lt;set&gt;和&lt;map&gt;。关于树的更多细节：（待整理。） 散列(hash) ：散列是一种利用表和散列函数来实现的特殊表结构，是一种用于以常数平均时间执行插入、删除和查找的技术。其不支持任何需要排序信息的操作。STL中依据散列表实现的ADT有&lt;unordered_set&gt;和&lt;unordered_map&gt;。关于散列的更多细节：（待整理。） 堆(heap) ：堆通常是指二叉堆。堆是一棵满足一定性质的二叉树。堆总是满足如下两个性质：1. 堆中某个节点的值总是不大于(或不小于)其父节点的值；2. 堆总是一棵完全二叉树。根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。堆是实现优先队列的首选结构。STL中利用堆实现的ADT有&lt;queue&gt;中的priority_queue。关于堆得更多细节：（待整理。） "},{"title":"前缀、中缀、后缀表达式","date":"2019-05-12T15:22:16.000Z","url":"/20190512-6.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"],["后缀表达式","/tags/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"],["栈ADT","/tags/%E6%A0%88ADT/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"]],"content":"一、简介前缀表达式、中缀表达式、后缀表达式都是数学中四则运算的表达方式。 日常生活中我们最常见的形如(a+b)xc表达式即中缀表达式，即操作符位于左右操作数的中间。但是计算机中利用中缀表达式计算求值则比较麻烦，需要将中缀表达式转换成表达式树，然后再递归进行计算，时间和空间复杂度都比较高。 为了便于计算机运算，波兰数学家Jan Lukasiewicz发明了前缀表达式，将操作符写在操作数的前面(如x+abc)，这样可以将四则运算用到的结构由树变成线性结构，大大提升了运算效率。为了纪念，人们将前缀称为波兰式。 但是因为将中缀表达式转变为前缀表达式，以及前缀表达式求值，都需要从右往左（从后往前）扫描表达式，不符合日常习惯，所以基于和前缀表达式类似的逻辑，又产生了后缀表达式，又称为逆波兰式。 计算机中通常采用的都是后缀表达式。 二、中缀表达式转换后缀表达式 利用栈存放操作符，记栈为S1； 从左往右扫描中缀表达式，当读到一个操作数时，立即将其输出； 当读到一个操作符+-x()时： 如果是(时，直接入栈S1； 如果是+-x，则比较该操作符与栈顶优先级，如果该操作符比栈顶优先级高或者栈顶是(，则直接入栈S1；否则弹出栈顶元素到输出，然后继续比较；其中优先级：( &gt; x &gt; + = -。 如果是)，则将栈S1元素弹出到输出，直到遇到一个(为止；此时将(移除栈S1但不输出； 当扫描完成，将栈S1中的元素挨个弹出到输出中。 例将中缀式1+((2+3)×4)-5转为后缀式： 扫描元素 栈S1 输出 说明 1 空 1 数字直接输出 + + 1 栈空，+直接入栈 ( +( 1 (直接入栈 ( +(( 1 (直接入栈 2 +(( 1 2 数字直接输出 + +((+ 1 2 栈顶是(，+直接入栈 3 +((+ 1 2 3 数字直接输出 ) +( 1 2 3 + )，弹出栈中元素直到遇到( x +(x 1 2 3 + 栈顶是(，x直接入栈 4 +(x 1 2 3 + 4 数字直接输出 ) + 1 2 3 + 4 x )，弹出栈中元素直到遇到( - - 1 2 3 + 4 x + +-优先级相同，所以弹出+，压入- 5 - 1 2 3 + 4 x + 5 数字直接输出 完成 空 1 2 3 + 4 x + 5 - 将栈中元素挨个弹出到输出 三、后缀表达式求值 利用栈存放操作数和中间结果，记栈为S1； 从左往右扫描后缀表达式，当读到一个操作数时，将其压入栈S1中； 当读到一个操作符时，从栈中弹出两个操作数，并用该操作符进行计算，再将所得结果压入栈中； 当扫描完成，栈中剩下唯一一个元素就是计算结果。 以后缀式1 2 3 + 4 x + 5 -为例： 扫描元素 栈S1 说明 1 1 数字直接入栈 2 1 2 数字直接入栈 3 1 2 3 数字直接入栈 + 1 5 弹出2 3，并将2+3结果入栈 4 1 5 4 数字直接入栈 x 1 20 弹出 5 4，并将5x4结果入栈 + 21 弹出1 20，并将1+20结果入栈 5 21 5 数字直接入栈 - 16 弹出21 5，并将21-5结果入栈 完成 16 栈中最后元素即为表达式结果 示例代码： "},{"title":"C++基础之字节对齐","date":"2019-05-12T15:20:23.000Z","url":"/20190512-5.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/tags/C-%E5%9F%BA%E7%A1%80/"],["字节对齐","/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["C++基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C-%E5%9F%BA%E7%A1%80/"]],"content":"本文转自C语言字节对齐问题详解, 做了一定的删减和修改。 1. 什么是字节对齐 现代计算机中内存空间都是按照字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序地一个接一个地排放，这就是对齐。 2. 对齐的原因和作用不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。 但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。 因此，通过合理的内存对齐可以提高访问效率。为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。 此外，合理利用字节对齐还可以有效地节省存储空间。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。 3. 对齐的分类和准则本文主要基于Intel X86架构介绍结构体对齐，栈内存对齐和位域对齐，位域本质上为结构体类型。 对于Intel X86平台，每次分配内存应该是从4的整数倍地址开始分配，无论是对结构体变量还是简单类型的变量。 3.1 结构体对齐在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型(如int、long、float等)的变量，也可以是一些复合数据类型(如数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界(alignment)分配空间。各成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。 字节对齐的问题主要就是针对结构体。 3.1.1 简单示例先看个简单的例子(32位，X86处理器，GCC编译器):【例1】设结构体如下定义： 已知32位机器上各数据类型的长度为：char为1字节、short为2字节、int为4字节、long为4字节、float为4字节、double为8字节。那么上面两个结构体大小如何呢？ 结果是：sizeof(strcut A)值为8；sizeof(struct B)的值却是12。 结构体A中包含一个4字节的int数据，一个1字节char数据和一个2字节short数据；B也一样。按理说A和B大小应该都是7字节。之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。 3.1.2 对齐准则先来看四个重要的基本概念： 数据类型自身的对齐值：就是基本数据类型的自身对齐值，比如char类型的自身对齐值为1字节，int类型的自身对齐值为4字节。 结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值，比如以上的struct A的对齐值为4。 指定对齐值：预编译命令#pragma pack （value）指定的对齐值value。 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。 其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。 基于上面定义和说明，我们可以方便的得出结构体字节对齐满足的三个一般性准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)； 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。 以此分析3.1.1节中的结构体B：假定对齐值默认为4，则char的有效对齐值为1，int的有效对齐值为4，short的有效对齐值为2；则结构体的有效对齐值为4；假设结构体B内存起始地址为0x0000, 按照结构体B的变量定义顺序，可以简单地知道变量char b内存地址为0x0000，占1个字节；变量int a 内存地址为0x0004，占4个字节；变量short c内存地址为0x0008，占2个字节。至此结构体的大小为(0x0008-0x0000) + 2 = 10; 根据结构体圆整的要求（准则3），编译器会在后面补充2个字节以满足4的整数倍要求，所以sizeof(struct B)=12。 再来看一个例子：【例2】假设4字节对齐，以下程序的输出结果是多少？ 执行后输出如下： 下面来具体分析：首先char a占用1个字节，没问题。short b本身占用2个字节，根据上面准则2，需要在b和a之间填充1个字节。char c占用1个字节，没问题。int d本身占用4个字节，根据准则2，需要在d和c之间填充3个字节。char e[3]；本身占用3个字节，根据原则3，需要在其后补充1个字节。因此，sizeof(T_Test) = 1 + 1 + 2 + 1 + 3 + 4 + 3 + 1 = 16字节。 3.1.3 对齐的隐患3.1.3.1 数据类型转换代码中关于对齐的隐患，很多是隐式的。例如，在强制类型转换的时候： 最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在X86上，类似的操作只会影响效率；但在MIPS或者SPARC上可能导致error，因为它们要求必须字节对齐。 3.1.3.2 排查对齐问题如果出现对齐或者赋值问题可查看： 编译器的字节序大小端设置； 处理器架构本身是否支持非对齐访问； 如果支持看设置对齐与否，如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。 3.1.4 更改对齐方式主要是更改C编译器的缺省字节对齐方式。 在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件： 使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐； 使用伪指令#pragma pack()： 取消自定义字节对齐方式。 另外，还有如下的一种方式(GCC特有语法)： __attribute((aligned (n)))： 让所作用的结构成员对齐在n字节自然边界上。如果结构体中有成员的长度大于n，则按照最大成员的长度来对齐。 __attribute__ ((packed))： 取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。 【注】__attribute__机制是GCC的一大特色，可以设置函数属性(Function Attribute)、变量属性(Variable Attribute)和类型属性(Type Attribute)。 3.2 栈内存对齐待整理。 3.3 位域对齐待整理。"},{"title":"面向对象设计之建造者模式","date":"2019-05-12T15:18:55.000Z","url":"/20190512-4.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"],["建造者模式","/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["设计模式","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。可以将复杂对象的创建过程独立出来，简化逻辑。 直接从代码感受吧 至此，组成几分套餐的基本成分就齐了，接下来我们再定义出套餐类 有了套餐元素和套餐类，我们就可以创建一个Builder对象，用于创建各种套餐。 有时候可能情况会更复杂一些，我们可能会这样定义MealBuilder: 为了让各种不同的建造者工作起来，就需要引入监工(Director)角色，通过监工来实现使不同的建造者通过统一的流程创建出不同的产品。 "},{"title":"面向对象设计模式之单例模式","date":"2019-05-12T15:17:37.000Z","url":"/20190512-3.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"],["单例","/tags/%E5%8D%95%E4%BE%8B/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["设计模式","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"单例是最简单的一种设计模式，其只有一个类定义，整个系统运行中，该类只允许存在一个实例。 单例模式不能让外部创建该类实例，只能自己类内部创建唯一实例，所以需要将构造函数私有化。 单例通常有两种实现方式：饿汉模式和懒汉模式。 恶汉模式：在系统初始化时创建实例。 恶汉模式将单例对象设置为静态对象，在程序启动时即可完成对象初始化，所以是线程安全的。 懒汉模式：实例在第一次被调用时创建 懒汉模式在多线程程序中是非线程安全的，可能会创造多个实例而造成内存泄漏。所以需要加锁。 但是保证线程安全，其实只需要在第一次调用时加锁，_instance赋值后，每次加锁就成了浪费的开销。所以为了解决这个问题，通常采用双重判断。 "},{"title":"面向对象设计模式之工厂模式","date":"2019-05-12T15:15:48.000Z","url":"/20190512-2.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"],["工厂模式","/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"],["抽象工厂","/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["设计模式","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"工厂模式有三类：简单工厂，工厂方法，抽象工厂。复杂度依次递增。 我们先假设有一组产品： 1. 简单工厂模式（Simple Factory）简单工厂不属于23种设计模式之一，只是简单地提供一个类，提供创建函数，根据产品类型创建产品对象。 2. 工厂方法模式（Factory Method）简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口，每增加一个具体产品类时，增加对应的具体工厂类，不需要修改之前的代码。但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加。 3. 抽象工厂模式（Abstract Factory）抽象工厂模式是针对多种不同的抽象产品，创建一个工厂接口，根据需要实例化不同的具体工厂类，每种具体工厂类都可以生产一组组合方式不同的具体产品。 "},{"title":"面向对象程序设计七大原则","date":"2019-05-12T15:12:24.000Z","url":"/20190512-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"],["设计原则","/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["设计模式","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"面向对象七大原则是人们总结的程序设计和设计模式的基础和指导思想。根据这七大原则编写的程序通常结构更合理，更易理解，易扩展，易维护。 1. 单一职责原则 (Single responsibility principle) 描述：一个类应该只有一个发生变化的原因。单一职责原则将不同的职责分离到单独的类，每一个职责都是一个变化的中心。这样做可以降低类的复杂度和耦合度，提升类代码的可读性和程序的可维护性。 2. 开闭原则（Open Close Principle） 描述：对扩展开放，对修改关闭。扩展程序尽量不去修改原有的代码，而是在原有代码基础上另行扩展，这样可以使程序具有良好的扩展性，易于维护和升级。 3. 里氏代换原则（Liskov Substitution Principle） 描述：任何基类可以出现的地方，子类一定可以出现。 LSP原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 4. 依赖倒转原则（Dependence Inversion Principle） 描述：面对接口编程，依赖于抽象而不依赖于具体实现。 当程序需要某种对象和其功能时，可以先抽象出该对象的功能接口，调用程序依赖该抽象进行编程，而具体实例对象类则继承该抽象接口或抽象类。 5. 接口隔离原则（Interface Segregation Principle） 描述：Client不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 这样做也是为了降低耦合。 以上五大原则是面向对象设计的基础原则，又统称为SOLID原则。后来又增加了另外两大原则。 6. 迪米特法则（Law of Demeter） 又叫最少知道原则（Least Knowledge Principle）。描述：一个对象应该对其他对象保持最小的了解。一个类在设计的时候应尽量将细节隐藏，只对外提供必要的接口；一个对象应当尽量少的与其他对象之间发生相互作用，使得系统功能模块相对独立。 7. 合成复用原则（Composite Reuse Principle） 描述：尽量使用合成/聚合的方式，而不是使用继承。 实际经验中，人们发现通常使用聚合方式来构建的类和对象，比继承具有更好的扩展性可维护性。 需要注意的是，虽然原则很有意义，但在实际项目中，应该注意度的把握，接口设计的过大或过小都不好，应该根据实际情况多思考再进行设计。"},{"title":"linux内存管理和虚拟内存","date":"2019-05-08T06:44:11.000Z","url":"/20190508-2.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["内存管理","/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"],["虚拟内存","/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":"一、虚拟内存简介在现代操作系统中，进程之间共享使用cpu和内存，但是内存资源有限，为了更加高效地使用内存，现代操作系统提供一个内存抽象—虚拟内存。 虚拟内存是操作系统内核为了对进程地址空间进行管理而精心设计的一个逻辑意义上的内存空间概念。我们编写程序中用到的内存都是在这个虚拟内存空间中进行分配。在程序运行中，操作系统通过地址管理单元（Memory Management Unit, MMU）和映射页表(page tables)来将需要访问的虚拟内存地址映射为物理内存地址。 虚拟内存提供三个重要的能力： 将内存当作磁盘的缓存，在内存中只保留常用数据，必要时从内存和磁盘之间交换数据。 简化内存管理，为每个进程提供统一的地址空间。 保护进程的内存空间不受其他进程影响。 二、虚拟内存机制以下文字和图片中用到的简称说明： VA: Virtual Address 虚拟地址PA: Physical Address 物理地址VP: Virtual Page 虚拟内存页PP: Physical Page 物理内存页PTE: Page Table Entry 页表项PTEA：Page Table Entry Address 页表项地址 2.1 地址映射在简介中我们提到了虚拟地址到物理地址的映射，下面是这种过程的示意图： 没有虚拟内存，cpu通过物理地址读取4个字节示意图:当cpu执行加载操作，它将有效的物理地址通过地址总线传给内存，内存从地址4开始读取4个字节，将这4个字节内容返回给cpu。 有虚拟内存，cpu通过虚拟地址读取4个字节示意图:cpu在加载虚拟地址（VA）之前，MMU（地址管理单元）会将VA转换成PA（物理地址），然后在执行正常的读取操作。 2.2 内存页进程的虚拟内存在物理内存和磁盘之间交换时以内存页（4kB）为最小单位。进程运行中，虚拟内存页有三种状态： 未分配：未在虚拟内存系统分配，只在页表存在一个记录，不占用内存和磁盘空间。 未缓存：已分配页，没有缓存在内存中，存于磁盘。 已缓存：已分配页，并缓存在内存中。 2.3 页表页表是用于内存页管理的的结构。其中记录了每个虚拟内存页（VP）对应的状态、与内存和磁盘之间的映射。如下示意图： 2.4 内存缓存命中与MISS当CPU访问某个虚拟内存地址时，如果页表中记录该地址所在的分页已缓存，则直接去对应物理内存中读取数据，这种情况称为缓存命中（cache hit）；当页表中记录该地址所在分页为分配或未缓存时，则会触发”缺页”异常（page fault exception），然后内核会分配新的物理内存页并建立页表映射，这种情况称为缓存未命中（cache miss）。 缓存命中的情形:缓存命中的流程： CPU将虚拟地址传给MMU， MMU生成PTE页表地址，去内存里拿页表。 内存返回页表给MMU， MMU根据页表查表后得到物理地址，去请求内存 根据物理地址，内存将数据返回给CPU 缓存miss的情形：缓存miss的流程： CPU将虚拟地址传给MMU， MMU生成PTE页表地址，去内存里拿页表。 内存返回页表给MMU， MMU发现PTE的valid标志位是0，将CPU的执行权交给操作系统内核的page fault异常处理程序（page fault exception handler）。 异常处理程序选中一个物理内存页（PP）剔除出去，如果该页内容相比之前有变动，同时将其内容写回磁盘。 异常处理程序将需要的页从磁盘里读取到内存里，并且更新内存里的页表里的PTE。 异常处理程序执行结束返回，CPU继续之前的寻址操作，现在一切情况都和 page hit 情况一样了。 从上面的步骤可以看出，page hit 这种情况可以在硬件基础上完成，可是 page fault 就需要操作系统内核配合完成了。 三、虚拟内存与内存管理3.1 进程的地址空间有了虚拟内存的机制，操作系统可以为每个进程提供独立的页表的虚拟内存空间，并且每个进程都可以有相同的内存布局。 每个进程拥有4G的进程地址空间，该空间被人为的分为两个部分——用户空间与内核空间。用户空间从0到3G（0xC0000000），内核空间占据3G到4G。用户进程通常情况下只能访问用户空间的虚拟地址，不能访问内核空间虚拟地址。只有用户进程进行系统调用（代表用户进程在内核态执行）等时刻可以访问到内核空间。 进程的用户内存空间又分为5个数据段： 代码段（text段）：存放可执行文件的操作指令（代码主体），只读。 数据段（data段）：存放初始化后的静态和全局变量，常量也存放在这个区域。 BSS段：存放未初始化的静态和全局变量，在程序载入时该段内存由内核清零。 堆（heap）：堆是“先进先出”的数据结构，用于存放进程运行中动态分配的内存。堆的内存地址向上增加；即堆上的数据越多，新分配的堆内存地址越大。 栈（stack）：栈是“后进先出”的数据结构，用于存放程序中的局部变量，包括函数调用时传入的参数和返回值。栈从内存空间的最高地址向下生长，和堆相对。 【注意，内存管理中栈的概念和作用与《数据结构》中类似， 而堆和数据结构中的堆不是一回事。】 进程内存分配如下图所示： ![](/images/2019/05/process_mem_plot.gif) 3.2 虚拟内存与内存管理每个进程拥有独立的虚拟内存空间和相同的空间布局，这样就为程序的链接、加载、代码与数据共享和程序内存分配等环节带来了便利，使相应工作变得相对简单。 简化链接：因为每个进程有独立的虚拟内存空间和相同的内存布局，这样的统一使得链接器的设计和实现变得简单，不管代码区或者数据区在物理内存的那个地方，链接器总能够根据统一规则生产一个可执行文件。 简化加载：当加载可执行文件和共享对象文件时，加载器不需要立即从磁盘copy全部可执行文件内容到内存里；只需为可执行文件建立页表并分配页表项（text段和data段），并将页表项映射到磁盘上的可执行文件。CPU加载或者执行指令时候发现相应的VP没有在缓存中，这时才会触发数据从磁盘copy到内存。 简化共享：单独的地址空间为操作系统提供了一个统一的机制用于管理用户进程和操作系统内核之间的内存共享。正常情况下，每个进程都有自己的代码、数据、堆和栈区域，进程之间不会共享，操作系统为每个进程创建的页表将进程虚拟页映射到不相交到物理内存中。但是有时候需要需要进程之间共享数据和代码。比如每个进程都要调用相同到操作系统内核代码，每个C程序都要调用标准C库函数printf函数。这时就要用到上图示意的共享PP的场景了。 简化内存分配：VM为用户态进程提供了一个简单机制用于分配额外内存。比如说，进程想额外从堆上分配内存（通过malloc系统调用），操作系统会分配k个连续堆虚拟内存页（k of VPs)，因为有页表的存在，在物理内存DRAM上没必要分配连续k页内存，k页可以分散开来。 "},{"title":"wordpress站升级HTTPS","date":"2019-05-08T06:39:22.000Z","url":"/20190508-1.html","tags":[["博客","/tags/%E5%8D%9A%E5%AE%A2/"],["wordpress","/tags/wordpress/"],["https","/tags/https/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"],["博客","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2/"]],"content":"现在越来越多的网站服务要求https，比如百度收录，微信小程序等等。今天抽空把博客升级了下，把过程记录下来，主要有这么几步： 准备ssl证书 设置证书自动续期 配置nginx或者apache支持https 更新wordpress配置和内链 重定向http到https 测试SSL支持 一、准备ssl证书现在基本上都是用的Let’s Encrypt免费证书，虽然只有90天有效期，但是续期很方便。官方给出的工具之一是开源软件certbot，支持基于ssh的平台（mac，linux)。 1.1 下载certbot 1.2 申请证书 运行后会自动安装和升级依赖，并安装ssl证书。需要注意一下几个问题： 该工具主要由python编写，通过pip包管理工具下载各种组件。pip默认源为国外地址，可能导致下载失败，所以最好切换为国内源。切换pip源 配置certonly，只下载安装证书，需要自己配置nginx或apache等http服务；如果不配置certonly，certbot会自动更新nginx配置ssl。 若不指定--nginx, certbot会提示用户选择nginx或者apache或其他http服务，并自动搜索配置文件；若报错找不到nginx或apache配置，则可以手动指定，对于nginx，指定的选项为：--nginx-server-root=/path/to/nginx/conf。 运行完成后会生成四个证书文件： 实际上，我们用两个证书文件就行了，一个是带私钥的文件，一个是带公钥的文件。 2. 设置证书自动续期证书续期很简单，certbot自带功能。证书快到期后，到certbot源码目录下执行： 执行成功后证书就自动更新了, 并且会自动更新nginx配置并重启nginx。 要设置自动更新，可以利用linux中的cron服务。cron是linux自带的定时任务程序。对于certbot，配置cron job，每两个月的第一天执行证书续期任务： 【注意】: cron job里面需要用绝对路径。 3. 配置nginx或者apache支持https直接以一个例子来说明，可以将其中ssl部分拷贝过去，并更改证书路径就可以了。 【注意】：为了安全性，只使用TLS协议，包括TLSv1.0，TLSv1.1，TLSv1.2，禁止 SSL 协议。 配置后重启nginx，wordpress应该就可以同时通过https和http访问了，但是还有些工作要做。 4. 更新wordpress配置和内链4.1 修改wordpress后台配置中的地址改为https版本。通过上面的设置，绝大部分导航中的链接就由wordpress系统自动改为HTTPS版本。对于正文中的内部链接还需要手工修改。 4.2 修改内链地址。一般有两种方法： 直接更新数据库。 利用wordpress提供的api来重写链接。在使用的主题（themes）的目录下的 function.php加入如下代码： 修改完了，可以在检查下源码如php,html,js,css等文件中，是否还有本站的http连接，再修改过来。 5. 重定向http到https一切都修改完了，http就可以永久重定向到https了。nginx重定向有多种写法，举例如下： 使用rewrite指令： 使用return指令: 对于重定向，推荐用return写法，性能比rewrite更优。 6. 测试SSL支持证书配置好了，我们可以利用一些第三方网站测试下自己网站的SSL支持情况。一个比较好的网站是：SSL Server Test。支持程度达到B以上就可以了。"},{"title":"开源镜像站整理（2019-04-21）","date":"2019-04-21T09:50:35.000Z","url":"/20190421-1.html","tags":[["开发资源","/tags/%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90/"],["镜像站","/tags/%E9%95%9C%E5%83%8F%E7%AB%99/"]],"categories":[["资源分享","/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"],["开发资源","/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90/"]],"content":"镜像站就是一些公共资源下载站的复制站点。对于一些无法访问或者访问缓慢的网络资源，镜像站可以提供访问下载和加快速度。以下收集了截止2019-04-21状况依然良好的镜像站点。 企业类 网易： 阿里巴巴： 华为云： 搜狐： 开源中国： 首都在线科技股份有限公司： 高校类 清华大学： 中国科学技术大学： 浙江大学： 华中科技大学： 上海交通大学： 重庆大学： 东软信息学院： 兰州大学： 港台镜像（内地可访问） “国立台湾大学”： “台湾國家高速網路與計算中心”：  ubuntu替换源： centos替换源 还有一件事没有做。那就是导入每个reposity的GPG key，前面说过，apt-get和yum都可以使用gpg对包进行校验，确保下载包的完整性，所以我们先要到各个repository站点找到gpg key，一般都会放在首页的醒目位置，一些名字诸如 RPM-GPG-KEY.txt之类的纯文本文件; 一般源会提供导入GPG key的指令， 格式如： npm镜像 淘宝npm： cnpm： 替换npm和yarn源： pypi镜像 阿里云  中国科技大学  豆瓣(douban)  清华大学  中国科学技术大学  替换pip源: linux下，修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下： windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容和linux一样。 "},{"title":"IO多路复用之select,poll,epoll总结","date":"2019-04-13T09:50:35.000Z","url":"/20190413-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["网络编程","/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"],["IO多路复用","/tags/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"],["selct","/tags/selct/"],["poll","/tags/poll/"],["epoll","/tags/epoll/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["网络编程","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"]],"content":"前篇: 网络编程之IO模型和IO多路复用 select, poll, epoll 在历史上是先后按顺序出现的，后者的提出都是为了解决前者遗留的问题。select是POSIX早期提出的规范，windows和linux等各大标准库都有实现。poll和epoll都是linux上的实现，其中poll和select差别很小, 在高并发和性能上有很大局限，而epoll则解决了大部分问题。 selectselect原型函数: select存在以下限制: 1 调用select函数会阻塞进程，直到有描述副就绪，或者超时2 单个进程能够监视的文件描述符的数量存在最大限制，通常是1024；想要修改限制只能通过修改内核宏定义;3 由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差;4 每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大，这个开销也很大;5 select返回的是含有整个fd集合，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；6 select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。 pollpoll 和 select 实现机制相似，只是内核用结构链表取代固定数组保存文件描述符集合，也就没有了最大文件描述数量的限制；但是select面临的其他问题，poll上依然存在。 poll原型函数: 可以看到，poll对select参数传值(readfds, writefds)稍有改进，pollfd结构包含了要监视的event和发生的event。和select函数一样，poll返回后，依然需要轮询pollfd数组来获取就绪的描述符。 epoll鉴于select和poll的缺陷，epoll采用了完全不同的事件驱动机制，上述select和poll存在的问题在epoll上不复存在。epoll在Linux内核中建立一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)，用来管理epoll对象。epoll对象封装了对于网络IO的所有操作，这样用户对IO的操作就转变为对epoll对象的操作。 epoll对用户提供三个调用接口: 简单来说，epoll的工作机制是这样的: 当调用epoll_create时，内核会创建一个epoll对象，epoll对象通过红黑树管理监听事件，通过双向链表存放发生的事件。 用户通过调用epoll_ctl向epoll对象注册/销毁监听事件；对于每一个添加到epoll对象中的事件，epoll都会向设备驱动程序注册回调(ep_poll_callback)。当驱动程序有事件发生时会调用该回调函数，它会将发生的事件添加到双向链表中。 当用户调用epoll_wait时，内核只需要检查epoll对象中的双向链表是否有事件。如果事件不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。(注意，epoll_wait依然可能造成阻塞。) 由此可见，epoll通过红黑树，双向链表等数据结构，以及事件回调机制，保证了其高效和应对并发的能力。 另外，epoll除了提供select/poll那种IO事件的水平触发(Level Triggered)外，还提供了边缘触发(Edge Triggered)，这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。 水平触发(LT):默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。 边缘触发(ET): 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。(直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次)。 总结可以用以下表格对比来看select, poll, epoll的区别: select poll epoll 操作方式 遍历 遍历 回调 底层实现 数组 链表 红黑树 IO效率 每次调用都进行线性遍历，时间复杂度为O(n) 每次调用都进行线性遍历，时间复杂度为O(n) 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1) 最大连接数 1024(x86)或2048(x64) 无上限 无上限 fd拷贝 每次调用select，都需要把fd集合从用户态拷贝到内核态 每次调用poll，都需要把fd集合从用户态拷贝到内核态 调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝 epoll是Linux目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超select和poll。目前流行的高性能web服务器Nginx正式依赖于epoll提供的高效服务。但是，在并发连接不高的情况下，多线程+阻塞I/O方式可能性能更好。"},{"title":"网络编程之IO模型和IO多路复用","date":"2019-04-08T15:28:40.000Z","url":"/20190408-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["网络编程","/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"],["IO模型","/tags/IO%E6%A8%A1%E5%9E%8B/"],["IO多路复用","/tags/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"],["异步IO","/tags/%E5%BC%82%E6%AD%A5IO/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["网络编程","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"]],"content":"对于学习服务端编程的程序员来说，网络IO是经常会涉及到的知识；同行聊天或者面试等等，也经常会被问到。比如阻塞IO，非阻塞IO，同步IO，异步IO等概念是怎么回事？select, poll, epoll 有什么区别等等。要搞清楚这些，需要了解一点linux系统相关的知识。下面简单梳理一下。 1 基础知识1.1 内核空间和用户空间 linux程序被执行后会成为一个进程，内核会为每个运行的进程提供了大小相同的虚拟地址空间，这使得多个进程可以同时运行而又不会互相干扰。对于32位机器而言，虚拟地址空间为4G(2的32次方)。 操心系统将虚拟空间划分为两部分，一部分为内核空间(1G:0xC00000000xFFFFFFFF)，一部分为用户空间(3G:0x000000000xBFFFFFFF)。进程运行时，属于内核部分的程序（如设备驱动）运行于内核空间，而用户程序运行于用户空间。 linux操作系统支持cpu提供的特权等级Ring0和Ring3，其中Ring0最高，Ring3最低。当进程在执行内核代码时，特权等级为Ring0，此时称进程处于内核态；而当进程执行用户代码时，特权等级为Ring3，此时称进程处于用户态。每个进程都拥有一个内核栈和一个用户栈，分别处于内核空间和用户空间。用户态到内核态的切换通常有三种方式：系统调用，异常，外围设备中断。 用户态和内核态的理解和区别 图示： 1.2 进程切换 进程在运行过程中一般有等待(阻塞/挂起)、就绪、执行三个状态；这是因为计算机在运行时，同一时间只能有一个进程处于执行状态。为了保证多进程的运行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。而控制进程切换的策略则被称为进程调度。 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 1.3 进程阻塞 正在执行的进程，由于期待的某些事件未发生，如请求系统资源、等待操作完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。 进程的阻塞、挂起和睡眠 1.4 直接I/O和缓存I/O 缓存I/O又被称作标准I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。 在Linux的缓存I/O机制中，对于write，数据会先被拷贝用户缓冲区，再拷贝到内核缓冲区，然后才会写到存储设备中。对于read，数据会先被拷贝到内核缓冲区，然后从内核缓冲区拷贝到用户缓冲区，最后交给用户程序处理。 缓存IO的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。 2 IO模型根据以上基础知识，我们知道IO读写是一个耗费资源和时间的过程。网络IO的模型大致有如下几种： 同步阻塞IO（blocking IO） 同步非阻塞IO（nonblocking IO） IO多路复用（ IO multiplexing） 信号驱动IO（ signal driven IO） 异步IO（asynchronous IO） 注：信号驱动IO在实际中并不常用，所以常见的主要是四种IO模型。 2.1 同步阻塞IO（blocking IO）同步阻塞IO即在整个IO系统调用的过程中，进程都处于阻塞状态。在linux中，默认情况下所有的socket都是blocking。 以read为例： 进程发起read，进行recvfrom系统调用，同时进程进入阻塞（进程是自己选择阻塞与否），等待数据； 内核开始准备数据（从磁盘拷贝到内核缓冲区），进程请求的数据并不是一下就能准备好；准备数据是需要时间的； 内核将数据从内核缓冲区拷贝到了用户缓冲区，内核返回结果，进程解除阻塞。 也就是说，内核准备数据和数据从内核拷贝到用户空间这两个过程都是阻塞的。 阻塞IO过程如下图所示： 优点： 能够及时返回数据，无延迟； 调用代码逻辑简单； 缺点： 等待浪费很多时间，影响程序性能； 2.2 同步非阻塞IO（nonblocking IO）同步非阻塞IO即在IO系统调用的过程中，进程不必阻塞，而是采用定时轮询(polling)的方式数据是否准备就绪；在此期间，进程可以处理其他的任务。 以read为例： 进程发起read，进行recvfrom系统调用，如果kernel中的数据还没有准备好，就立刻返回一个error； 调用返回后进程可以进行其他操作，然后再次发起recvfrom系统调用，不断重复；(这个过程称为轮询polling) kernel中的数据准备好以后，再次收到recvfrom调用，就将数据拷贝到了用户内存，然后返回； 需要注意，在数据从内核拷贝到用户内存的过程中，进程仍然是属于阻塞的状态。 非阻塞IO过程如下图所示： 优点： 能够在IO操作过程中，处理其他的任务。 缺点： 任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。 2.3 IO多路复用（IO multiplexing）I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。常见的select, poll, epoll 都是IO多路复用。需要注意的是，select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。 IO多路复用过程如下图所示： 关于select, poll, epoll的细节：select、poll、epoll之间的区别总结 2.4 异步IO（asynchronous IO）异步IO是事件驱动IO。用户进程发起IO操作之后，会立即返回，然后可以处理其他任务。kernel会等待数据准备完成，然后将数据拷贝到用户内存。当这一切都完成之后，kernel会给用户进程发送一个signal，通知IO操作完成。在IO两个阶段，进程都是非阻塞的。目前有很多开源的异步IO库，例如libevent、libev、libuv。 异步IO过程如下图所示： 3 IO模型总结先通过下图来看看5种IO模型的区别： 3.1 blocking和non-blocking区别调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。 3.2 synchronous IO和asynchronous IO区别在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的： A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes; An asynchronous I/O operation does not cause the requesting process to be blocked; 两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。 3.3 non-blocking IO和asynchronous IO的区别 在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的检查，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。 asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。 "},{"title":"数据库优化整理总结","date":"2019-04-03T08:32:35.000Z","url":"/20190403-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MYSQL","/tags/MYSQL/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据库","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"content":"数据库优化有很多种策略，基本方向有结构设计优化，索引优化，语句优化，分库分表，读写分离，缓存利用以及系统配置优化和硬件优化。其中最关键的就是设计初期建立合理的数据结构。这对于后期性能优化至关重要。因为数据库结构是系统的基石，基础打不好，使用各种优化策略，也不能达到太好的效果。 一. 数据库设计 数据库设计有一个经典的三范式规则，目的是为了建立冗余较小、结构合理的数据库。 第一范式：确保每列数据保持原子性 第二范式：确保表中的每列都和主键相关 第三范式：确保每列都和主键列直接相关，而不是间接相关&gt;&gt;&gt; 数据库三范式详解 三范式作为一个基本依据，但不要生搬硬套，有时候合理的冗余设计是必要的。 合理的使用字段类型和约束。SQL数据库有五大约束： PRIMARY KEY, FOREIGN KEY, UNIQUE, DEFAULT, NOT NULL 二. 索引优化索引是用来对数据进行定位的方法，索引的类型通常有：主键索引，唯一索引，聚集索引，非聚集索引。合理的使用索引会让查询更高效，但是索引的使用是有一定代价的。好处： 可以大大加快数据的查询速度，可以加速表和表之间的连接操作。 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 代价： 索引需要占用硬盘存储空间。 当对表中的数据进行增删改的时候，索引也要动态的维护，会占用了一定时间。 &gt;&gt;&gt; 索引详解 索引通常建立在使用频繁, 数据重复不多, 数据不太复杂的列。对于很少使用，或者重复量多（如枚举类型或者允许NULL），或者数据复杂（如text）的列，不应该建立索引。 注意有些使用情境下，虽然建立了索引，但是并没有起到作用。 当在where子句中对字段进行null值判断时，将导致引擎放弃使用索引而进行全表扫描。 当在where子句中对索引字段进行非等值判断时，如!=,&lt;,&gt;,NOT IN等，将导致引擎放弃使用索引而进行全表扫描。 当在where子句中对索引字段进行运算操作时，包括函数，计算表达式等，将导致引擎放弃使用索引而进行全表扫描： 如where age + 10 = 30;where substr(name) = ‘Kevin’; 当对索引字段进行like模糊查询时，如果待匹配字符串第一个字符为模糊匹配符%，则不会用到索引：如where name like ‘%kevin’; 当在 where 子句中使用or来连接条件时，如果其中一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。 三. 语句优化语句查询涉及到很多琐碎的方面，这里大概列举一些： 对于频繁where查询，尽量利用上索引；对于没有建立索引或者索引无效的，建立合适的索引或者修改语句以便利用索引。 合理调整where条件的顺序，将能过滤掉更多数据的条件放在末尾。 避免采用 select *, 这会占用更多时间。 理论上，尽量使用多表连接（join）查询，避免子查询。 对于LIMIT查询，先在索引上完成排序分页操作，最后根据主键关联回表查询所需要的其他列内容。 充分利用查询优化器，多处存在相同的查询语句时，尽量保持一样（大小写也一致）。 利用explain语句来分析语句执行情况，针对性优化。 四. 分库分表MySQL单表的数据量在500w-1000w之间性能比较好，单库数据量在5000w以内性能比较好,,超过阈值性能都会下降。同时单库单表在IO读写和数据库连接上都存在着限制。为了提升性能和解决以上问题, 在数据量和并发访问量大时，分库分表时必要的。 分库分表有水平拆分和垂直拆分。&gt;&gt;&gt; 分库分表详解 五. 读写分离一台数据库支持最大连接数是有限的，如果用户的并发访问很多，一台服务器无法满足需求。这时候可以采用读写分离的方式进行集群。读写分离采用主从配置，一台master,多台slave, 所有写操作都往master上写，读操作往从Slave上读。Slave数据库从Master同步数据。mysql支持读写分离配置。&gt;&gt;&gt; mysql读写分离介绍和搭建 六. 缓存利用缓存可以在一定程度上避免磁盘IO读写，节省查询时间。常见的缓存服务有Redis/Tair/Memcached等。&gt;&gt;&gt; redis作为mysql缓存 七. 系统配置优化通过修改数据库的配置，来提升数据库性能，如mysql的my.cnf配置。有时候优化过程中，需要找到影响性能的sql语句，可以通过配置my.cnf打开mysql的慢查询日志。&gt;&gt;&gt; 慢查询详解"},{"title":"WP Super Cache 导致DUX模板前端登录失效的问题","date":"2019-04-02T13:06:35.000Z","url":"/20190402-1.html","tags":[["博客","/tags/%E5%8D%9A%E5%AE%A2/"],["wordpress","/tags/wordpress/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"],["博客","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2/"]],"content":"最近将wordpress博客模板从XIU切换为DUX，基本上调整不多，比较顺利。但是完成后发现DUX前台登录没有反应，chrome开发者工具看到登录和注册的POST请求accept JSON数据，结果返回了一个HTML（博客首页）。一开始怀疑是自己添加的登录保护代码和nginx配置问题，捣鼓了半天依然没有解决，想不通是什么原因。后来才想到可能是缓存的问题，尝试进后台禁用WP Super Cache，发觉竟然OK了，但还是不知道什么原因。 虽然看起来是好了， 但是不能因为这么个蛋疼问题就不用缓存了吧。于是百度了下，发觉WP Super Cache导致前台登录失效的问题网上有一些人提出和解决了, 缓存文件延迟初始化选项默认是勾选的，取消掉就好了。（如下图） 竟然就这么轻松解决了，浪费了好多脑细胞。"},{"title":"wordpress新站需要关心的几件事","date":"2018-09-23T12:06:30.000Z","url":"/20180923-1.html","tags":[["博客","/tags/%E5%8D%9A%E5%AE%A2/"],["wordpress","/tags/wordpress/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"],["博客","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2/"]],"content":"写在前头wordpress是一个非常强大的建站工具，其无数强大和美观的插件几乎可以实现你想要的一切功能。新建wordpress站通常容易陷入不停尝试各种插件的过程里，你会发现很多插件都能让你惊叹并喜欢的不要不要的。 然而必须要知道，用插件是有代价的。第一点，插件用多了会严重影响wordpress网站前后台页面响应速度；第二点，很多插件都会生成额外的数据库表或者插入额外的数据，这些额外的数据并被会随着插件的卸载而删除，大量不用的插件的数据遗留在数据库里也会对数据查询和数据库备份造成不必要的负面影响；第三，很多插件的功能互相之间有冲突或重叠，这些对于网站的效率和日常维护也会带来不好的影响。 所以谨慎选择插件是非常有必要的。建站之前， 必须要清楚自己想要一个什么样的站。再根据站点的类型相应的选择插件和功能。 笔者建站以来也走了不少的弯路，下面就这个过程总结一下经验，把建站初期需要做的几件事记录下来。 1. 设置对搜索引擎不可见网站新建初期，很多东西没有准备好，可能会面临频繁的改动；如果这时候被搜索引擎蜘蛛爬到了，可能被收录很多不存在和错误的页面，会严重影响后来网站SEO评级。笔者建站之初因为没这方面经验，吃了一些亏。其设置位置在：设置（Settings）– 阅读 – 对搜索引擎可见性, 设置勾选。注意：在网站稳定后，记得取消勾选，让搜索引擎可以收录本站文章。 2. 设置固定链接这个是为了SEO方便，固定连接设置为伪静态的格式有利于搜索引擎收录。注意这个设置在网站正式开始运营后就不要再改动了，后期修改的话对网站排名影响很大。其设置的位置在：设置（Settings）– 固定连接。注意：设置静态格式的固定连接后需要设置nginx或apache的伪静态规则，否则页面无法打开。伪静态规则可以自行百度复制一个。 3. 禁用国外链接wordpress默认采用google字体和gravatar头像库，这两个链接都在国外，会严重拖慢网站打开速度。可以采用插件将字体和头像切换为使用国内CDN，或者干脆禁用掉。这里推荐WP Acceleration for China插件和WP User Avatar插件。 4. 采用缓存加速采用缓存可以大大提升网站的访问速度，同时很多页面不用动态生成，可以降低主机负荷。好处就不用多说了，对于会不断更新的站点，这个属于必备。这里推荐使用WP super cache插件。 5. 设置网站地图网站地图是SEO必备的东西，不多说，这里推荐Baidu Sitemap Generator，国内使用人数比较多的地图插件。 6. 设置robots.txtRobots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。搜索引擎网络爬虫访问网站时，首先会寻找站点根目录下的robots.txt文件，根据该文件指示确定收录范围；如果站点没有该文件，网络爬虫就会默认抓取所有页面，而这通常是对网站不利的。这里放一个常用的适合wordpress站点的robots.txt文件的内容： 注意上面将sitemap的url替换成自己站点的sitemap地址。 7. 选择SEO插件最常见的SEO插件是All in One SEO Pack和Yoast。这两个插件功能都比较强大全面。但是有些主题也自带SEO功能，这样就不用安装SEO插件了。但是用主题自带SEO功能也必须知道一个问题：主题自带SEO功能在站点切换主题时可能会不兼容而丢失，而用SEO插件不会有这样的问题；所以可以根据自己的站点情况进行取舍。 8. 处理登录安全虽然wordpress已经很安全，但是暴力破解攻击依然会造成问题。这里推荐一个登录安全插件：Login LockDown。它可以尝试记录登陆失败的ip地址和时间、限制某ip或ip段登陆、还能控制同ip密码输入错误的次数，如果超过一定的次数，就封锁限制此ip，能够有效防止密码被暴力破解。 9. 隐藏登录注册如果你的站点不打算对外开放注册，可以设置禁止注册，并隐藏前台登录和注册接口。该设置位于： 设置（Settings）- 常规。 隐藏前台登录和注册，可以在主题的functions.php中添加如下代码： 同时为了保护后台登录，可以将后台登录地址进行隐藏，其中一种常用方法如下： 这样只有当访问地址是 时，才可以正常进入登录界面。 10. 限制文章版本记录wordpress 文章默认每次修改保存就会产生一个新的版本，同时wordpress也会自动保存对文章生成新版本。通常情况下，这些文章版本都不是全部必要的，其只会无用的增大数据库负担。 我们可以通过wordpress内置的方法禁用或限制版本记录，其方法为：打开站点根目录下的 wp-config.php 文件，在靠前部分增加代码： 对于已经产生的revision, 可以通过数据库删除。 注意保持该代码中SQL语句的执行顺序。 建设好一个wordpress站点，还有很多工作要做，许多上面没有列出的功能对某些站点也是非常重要，比如注册插件， 评论插件， 个人中心插件，商城和分销插件等等，需要大家根据自己的站点需求来添加。"},{"title":"Linux 常用命令总结（二）：find和grep命令","date":"2018-09-22T12:06:30.000Z","url":"/20180922-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["linux命令","/tags/linux%E5%91%BD%E4%BB%A4/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":"find和grep都是与文件和内容查找有关的命令，在linux中使用的频率非常高，是必须掌握的linux基础命令。 find根据指定的规则（如文件名、文件类型、用户甚至是时间戳等），在一个目录树中搜索文件，并可以对搜索结果执行给定表达式。 常用形式 其中expression包含三类：options, tests, actions，还可以用operators进行逻辑运算。 options常用选项 -d -depth 查找/处理文件时按深度优先（先处理子文件夹的内容） -maxdepth &lt;level&gt; (level为非负整数) 处理path目录时向下查找最多level级；例如-maxdepth 0表示仅查找/处理path目录而不管其子目录下的内容。 -mindepth &lt;level&gt; (level为非负整数) 对从path目录开始到向下level级目录不执行tests和actions；-mindepth 1表示处理除了path目录外的所有文件和子目录。 tests常用测试项 -name &lt;pattern&gt; 根据名称查找文件，pattern仅仅表示文件名，不能是路径(不能包含 &#39;/&#39;)；元字符(&#39;*&#39;, &#39;?&#39;, &#39;[]&#39;)可以匹配文件名开头的&#39;.&#39;。 -path &lt;pattern&gt; 根据路径查找文件；pattern中的&#39;/&#39;和&#39;.&#39;不会特殊处理，正常匹配路径。 -regex &lt;pattern&gt; 根据路径的正则表达式查找文件。 -size &lt;n&gt;[cwbkMG] 根据大小查找文件,c表示bytes, w表示words, b表示blocks(512bytes),k表示kB, M表示MB, G表示GB。&lt;n&gt;都可以表示为+n,-n,n三种形式；+n 表示大于n，-n 表示小于n，n表示正好等于n。 -empty 可以匹配空文件和空目录 -type c 按文件类型查找，c通常取值为&#39;f, d, l, s, p&#39;。f表示普通文件，d表示文件夹，l表示符号链接，s表示socket文件, p表示管道文件。 -user &lt;uname&gt; 根据文件拥有者用户名（或ID）查找 -group &lt;gname&gt; 根据文件所属的用户组名（或ID）查找 还有许多其他选项，可以根据文件的读写属性，访问权限，访问时间和修改时间，所在文件系统等等一系列条件来查找文件，这里就不一一列举了，具体请用man find查阅。 actions常用操作项 -delete 对匹配的文件进行删除，自动开启-depth模式。 -print 将查找的文件打印到标准输出；每个文件名后加一个newline字符(&#39;\\n&#39;)。 -print0 将查找的文件打印到标准输出；每个文件名后加一个null字符(&#39;\\0&#39;)。 -printf &lt;format&gt; 将查找的文件按format格式打印到标准输出；format格式类似C语言printf。 -fprint &lt;file&gt; | -fprint0 &lt;file&gt; | -fprintf &lt;file&gt; &lt;format&gt; 将查找的文件打印到file文件，file文件一定会被创建，其他跟print系列差不多。 -exec &lt;cmd&gt; ; 对每一个匹配的文件执行一次cmd命令(&#39;;&#39;不可少)；当前文件名将替换cmd中的每一个’{}’符号；（因为cmd在查找的启动目录中执行，不可避免的会有安全问题，man建议用-execdir而不用-exec）。 -exec &lt;cmd&gt; &#123;&#125; + 意义和上面一个差不多，不过找到的文件名参数传递给cmd的格式不一样；所有的文件名拼到一起传递给cmd，cmd调用次数更少，只能有一个&#39;&#123;&#125;&#39;符号。 -execdir &lt;cmd&gt; ; 安全版本的exec，cmd命令在当前匹配文件所在的目录中执行，可以有效避免race condition问题。 -execdir &lt;cmd&gt; &#123;&#125; + 同上 -ok cmd ; 和exec作用相同，只是每次执行命令前需要用户确认。 operators常用运算符 (expr) 小括号运算符表示运算优先级，因为小括号对于shell来说是特殊字符，所以需要转义并用引号引起来；如&#39;\\(...\\)&#39;。 ! expr 表达式的值取反。 expr1 -a expr2 表达式and运算, -a是默认行为，可以省略。 expr1 -o expr2 表达式or运算。 expr1 , expr2 表达式并列运算，和一般的逗号运算符作用一样。 例子 find与xargs命令 xargs命令组合多个命令的工具，能够处理管道或者stdin并将其转换成特定的参数传递给其他命令。 find虽然有-exec动作选项执行命令，但有些系统对能够传递给exec的参数长度有限制，find命令将所有匹配到的文件一起传递给exec执行时，容易出现溢出错误，错误信息通常是“参数列太长”或“参数列溢出”，这时候就需要xargs出马解决问题。另外，在有些系统中，使用-exec时每处理一个匹配到的文件就发起一个进程，这样在有些情况下就会出现进程过多，系统性能下降的问题。 使用xargs命令只有一个进程，而且可以分多次获取参数并执行命令，在获取参数时，一次获取参数的数目可以根据该命令的选项及系统内核中相应的可调参数来确定。 所以find命令通常都会跟xargs一起使用。下面是一些例子： grepgrep 是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 常用形式 常用选项 -i，--ignore-case 搜索时忽略大小写差别。 -c, --count 只打印匹配的行数，不显示匹配的内容。 -n，--line-number 打印匹配行时，在其前面打印行号。 -b, --byte-offset 打印匹配行时，在其前面打印匹配位置在文件中的字节位移(0 based byte offset)。 -&lt;n&gt; 同时显示匹配行上下的n行，如：grep -2 pattern a.txt同时显示匹配行的上下2行。 -f FILE 从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。 -h，--no-filename 不打印匹配内容前面的文件名前缀；这是搜索单个文件时的默认行为。 -H，--with-filename 打印匹配内容前面的文件名前缀；这是搜索多个文件时的默认行为。 -l, --files-with-matches 不打印正常输出，只打印含有匹配内容的文件清单。 -L, --files-without-matches 不打印正常输出，只打印不含有匹配内容的文件清单。 -q, --quiet 不打印任何东西，只返回退出状态。状态为0则表示找到了匹配的行。 -s, --no-messages 不显示关于不存在或者无法读取文件的错误信息。 -v，--invert-match 反检索，只显示不匹配的行。 grep正则表达式基本元字符 模式 说明 例子 ^ 锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。 $ 锚定行的结束 如：&#39;grep$&#39;匹配所有以grep结尾的行。 . 匹配一个非换行符的字符 如：&#39;gr.p&#39;匹配gr后接一个任意字符，然后是p。 * 匹配零个或多个先前字符 如：&#39; *grep&#39;匹配所有一个或多个空格后紧跟grep的行。 .*一起用代表任意字符。 [] 匹配一个指定范围内的字符 如：&#39;[Gg]rep&#39;匹配Grep和grep。 [^] 匹配一个不在指定范围内的字符 如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行。 \\(..\\) 标记匹配字符 如：&#39;\\(love\\)&#39;，love被标记为1。 \\&amp;lt; 锚定单词的开始 如：&#39;\\&amp;lt;grep&#39;匹配包含以grep开头的单词的行。 \\&amp;gt; 锚定单词的结束 如：&#39;grep\\&amp;gt;&#39;匹配包含以grep结尾的单词的行。 x\\&#123;m\\&#125; 连续重复字符x，m次 如：&#39;o\\&#123;5\\&#125;&#39;匹配包含连续5个o的行。 x\\&#123;m,\\&#125; 连续重复字符x,至少m次 如：&#39;o\\&#123;5,\\&#125;&#39;匹配至少连续有5个o的行。 x\\&#123;m,n\\&#125; 连续重复字符x，至少m次，不多于n次 如：&#39;o\\&#123;5,10\\&#125;&#39;匹配连续5-10个o的行。 \\w 匹配一个文字和数字字符，也就是[A-Za-z0-9] 如：&#39;G\\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W w的反置形式，匹配一个非单词字符 如：点号句号等。\\W*则可匹配多个。 \\b 单词锁定符 如: &#39;\\bgrep\\b&#39;只匹配grep，即只能是grep这个单词，两边均为空格。 "},{"title":"古风歌曲推荐：心然专辑","date":"2018-09-20T12:27:21.000Z","url":"/20180920-1.html","tags":[["音乐推荐","/tags/%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90/"],["古风音乐","/tags/%E5%8F%A4%E9%A3%8E%E9%9F%B3%E4%B9%90/"],["古风唱曲","/tags/%E5%8F%A4%E9%A3%8E%E5%94%B1%E6%9B%B2/"],["心然","/tags/%E5%BF%83%E7%84%B6/"]],"categories":[["生活学习","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"],["音乐","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E4%B9%90/"]],"content":"心然，古风音乐圈最早最出名的歌手，古风音乐圈的鼻祖和奠基人之一。现在知道然姐的可能不多了，但是当年古风音乐刚开始发展的时候，然姐一个人可以说撑起了古风音乐的半边天。 然姐的嗓音空灵而清澈，甜美中带着淡淡的忧伤，听着她的歌，眼前仿佛看到一副水中仙子月下独舞的美好画面， 让人不禁沉迷。所谓灵魂歌者，然姐应该可以担当的起吧。 笔者当初正是因为偶然听到然姐的歌声，然后一发不可收拾，深深的陷入了古风音乐的世界里了，往后至今所听所唱的歌都是古风，可谓对人生影响深远；这其中的美好，值得一生用心珍藏。 下面是然姐的一些歌单，看到的小伙伴们好好欣赏吧^^ "},{"title":"Linux 常用命令总结（一）：文件和目录操作命令","date":"2018-09-19T12:07:29.000Z","url":"/20180919-2.html","tags":[["ACGN","/tags/ACGN/"],["SAO","/tags/SAO/"],["刀剑神域","/tags/%E5%88%80%E5%89%91%E7%A5%9E%E5%9F%9F/"]],"categories":[["ACGN","/categories/ACGN/"]],"content":"刀剑神域（Sword Art Online）简称SAO, 日本网游类型的轻小说，自2011年发表以来至今一直在轻小说评选活动“这本轻小说真厉害！”中排名前5。其后被不断改变为游戏，漫画，TV动画, 真人电视剧等，可见其受欢迎程度。在中国拥有众多的粉丝，提起这本小说，大家通常亲切的称呼为“我大刀剑”，足以说明这部小说在读者心中的分量。非常难得的是，这部小说写出了读者心中所梦想的游戏故事场景，塑造出了很多人都很喜欢的人物性格。顺便一提，笔者也是SAO的忠实粉丝哦~ 下面附上我大刀剑的宣传图和小说下载链接~ ![刀剑神域](/images/2018/09/daojian.jpg) ![刀剑神域](/images/2018/09/daojian1.jpg) 下载链接： "},{"title":"Linux 常用命令总结（一）：文件和目录操作命令","date":"2018-09-19T12:06:29.000Z","url":"/20180919-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["linux命令","/tags/linux%E5%91%BD%E4%BB%A4/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":"整理下linux基础命令，对于各种命令，仅仅列出常用的选项，如果想知道更详细，建议用cmd -h或者man cmd查看。以下是最基本的文件操作命令。 pwd &emsp;不带参数, 显示当前目录 cd [path] &emsp;切换当前工作目录 &emsp;范例 cd 不带参数，切换到用户的home目录 cd ~ 和不带参数一样，切换到用户的home目录 cd - 退回到切换前的目录 cd .. 切换到上一级目录 ls [-alh] [path] &emsp;显示目录文件列表；不带path参数，显示当前目录文件列表 &emsp;选项 -a 显示所有文件及目录，包括隐藏文件和目录 -l 输出结果用单列格式显示，包含更详细的信息（默认输出为多列） -h 将文件和目录大小以便于人类阅读的方式显示（eg, 21K, 15M, 3.2G） mkdir [OPTIONS] DIRECTORY... &emsp;如果目录不存在，则创建目录（可以） &emsp;选项 -p 一次创建多级目录，如mkdir -p a/b/c/d -v 对每个创建的目录输出一条消息 rmdir [OPTIONS] DIRECTORY... &emsp;删除空目录（只能删除空目录） &emsp;选项 -p 一次删除多级空目录，如rmdir -p a/b/c/d -v 对每个删除的目录输出一条消息 rm [OPTIONS] FILE... &emsp;删除文件或目录(这个比rmdir更常用) &emsp;选项 -f 忽略不存在的文件或参数而不提示 -r -R 递归删除目录 -i 每一次删除前提示选择是否删除 -v 解释命令过程中的细节 touch [OPTIONS] FILE... &emsp;如果FILE存在，更新FILE的访问和修改时间到当前时间&emsp;如果文件不存在并且-c没有指定，则创建一个空文件 &emsp;选项 -a 仅仅更新文件访问时间 -m 仅仅更新文件修改时间 -c 不创建任何文件 cp [OPTIONS] SOURCE DESTcp [OPTIONS] SOURCE... DIRECTORYcp [OPTIONS] -t DIRECTORY SOURCE... &emsp;第一种格式是单文件拷贝；后面两种是将多文件拷贝到指定目录中 &emsp;选项 -n 不覆盖已经存在的文件 -i 碰到已存在的文件时提示选择是否覆盖 -f 碰到已存在的文件直接覆盖 如果-n和-i都存在，只有后面一个生效；如果-n存在，则忽略-f -l 生成硬链接而不实际发生拷贝 -s 生成软连接（符号链接）而不实际发生拷贝 -v 解释命令过程中的细节 mv [OPTIONS] SOURCE DESTmv [OPTIONS] SOURCE... DIRECTORYmv [OPTIONS] -t DIRECTORY SOURCE... &emsp;第一种格式是单文件移动并/或重命名；后面两种是将多文件移动到指定目录中 &emsp;选项 -n 不覆盖已经存在的文件 -i 碰到已存在的文件时提示选择是否覆盖 -f 碰到已存在的文件直接覆盖 如果-n，-i，-f存在不止一个，只有最后一个生效 -u 仅当目标文件不存在或者SOURCE文件较新时移动文件 -v 解释命令过程中的细节 cat [OPTIONS] FILE... &emsp;1. 显示整个文件内容 cat file&emsp;2. 将标准输入写入一个新的文件（创建文件） cat &gt; file (以Ctrl+D作为输入结束)&emsp;3. 将一个或多个文件内容合并写入到另一个文件 cat file1 file2 &gt; file3 (文件3的内容将丢失)&emsp;4. 将一个或多个文件内容追加到另一个文件末尾 cat file1 file2 &gt;&gt; file3 &emsp;选项 -n 显示输出行号(不是文件的真实行号) -s 显示时缩减连续多个空行为一个空行 &emsp;范例 cat &lt;&lt;EOF &gt; file或者cat &gt; file &lt;&lt;EOF 将标准输入写入文件并以EOF结束（这里EOF可以替换为任意常规字符串） cat -n file1 file2 &gt; file3 将file1, file2的内容加上行号输入到file3 cat /dev/null &gt; file 清空文件内容 head [OPTIONS] FILE... &emsp;输出文件的开头部分内容，默认输出前10行。如果是单个文件，默认不输出文件名；如果是多个文件，则默认输出文件名。 &emsp;选项 -c&lt;num&gt; 输出开头的num个字节；如果num以-开头，则输出除最后num字节外的全部内容 -n&lt;num&gt; 输出开头的num行；如果num以-开头，则输出除最后num行外的全部内容 -q 强制不输出文件名 -v 强制输出文件名 tail [OPTIONS] FILE... &emsp;输出文件的最后部分内容，默认输出最后10行。如果是单个文件，默认不输出文件名；如果是多个文件，则默认输出文件名。 &emsp;选项 -c&lt;num&gt; 输出最后的num个字节；如果num以-开头，则输出除前num字节外的全部内容 -n&lt;num&gt; 输出最后的num行；如果num以-开头，则输出除前num行外的全部内容 -q 强制不输出文件名 -v 强制输出文件名 -f 如果文件内容增长, 输出新增加的内容 more [OPTIONS] FILE... &emsp;more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。 more命令只能向前浏览文件。 &emsp;选项 +&lt;num&gt; 指定从num行开始显示 -&lt;num&gt; 指定每屏显示的num行 -d 显示提示[press space to continue,’q’ to quit.]”和“[Press ‘h’ for instructions] -c 不进行滚屏操作，每次刷新当前屏幕 -s 将多个空行压缩成一行显示 -u 禁止下划线 less [OPTIONS] FILE... &emsp;less命令的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页，按Q键退出less程序。 &emsp;选项 -e 文件内容显示完毕后，自动退出 -f 强制显示文件 -g 不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度 -l 搜索时忽略大小写的差异 -N 每一行行首显示行号 -s 将连续多个空行压缩成一行显示 -S 在单行显示较长的内容，而不换行显示 -x&lt;num&gt; 将TAB字符显示为指定个数的空格字符 "},{"title":"一些古风的纯音乐推荐","date":"2018-09-17T12:27:21.000Z","url":"/20180917-1.html","tags":[["音乐推荐","/tags/%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90/"],["古风音乐","/tags/%E5%8F%A4%E9%A3%8E%E9%9F%B3%E4%B9%90/"],["纯音乐","/tags/%E7%BA%AF%E9%9F%B3%E4%B9%90/"]],"categories":[["生活学习","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"],["音乐","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E4%B9%90/"]],"content":"笔者是古风迷，一直认为，古风音乐是中华民族的精神国粹，是世间最美好的事物之一。让我们一起来静静听一听这些让人沉醉的古风音乐吧。 绯羽怨姬出自《霹雳神州II之苍玄泣》 霹雳布袋戏剧集原声带 织梦行云出自《仙剑奇侠传四》，仙剑系列笔者当年沉迷了好久，曾和同学宅在宿舍废寝忘食的玩这个游戏。 荀彧出自 《国家宝藏》综艺节目插曲 深山幽谷(中音笙 二胡)出自 班得瑞（Bandari）， 大名鼎鼎的班得瑞，不解释。 草原の涙出自 磯村由纪子《風の住む街》。日本的古风音乐也很不错，很多不错的音乐在国内流传很广，比如大名鼎鼎的久石让。 美夕八千夜出自动漫《吸血姬美夕》，这部动漫和《地狱少女》的风格比较类似，美夕和小爱都是悲伤命苦，却又善良的孩子，让人心生怜爱。 神魔の鼓动出自动漫《吸血姬美夕》 地狱の川流れ出自动漫《地狱少女》 悲运の巫女出自动漫《犬夜叉》（笔者最爱的动漫，入宅番，当年喜欢的不要不要的，现在依然是挚爱之一） 时代を超える想い出自动漫《犬夜叉》 以上音乐感觉怎么样呢？觉得好的话请给我点赞或留言评论哦~"},{"title":"2018秋季最值得期待的动漫，不要错过哦","date":"2018-09-16T02:55:22.000Z","url":"/20180916-2.html","tags":[["ACGN","/tags/ACGN/"],["动漫推荐","/tags/%E5%8A%A8%E6%BC%AB%E6%8E%A8%E8%8D%90/"]],"categories":[["ACGN","/categories/ACGN/"]],"content":"2018年9月已经过半，随着7月番的渐渐收尾结束，漫友们是不是觉得又渐渐漫荒了呢。不过不用担心，属于秋季的10月新番就快啦。而今年的10月新番，质量和数量都挺高，一定会让属于二次元的朋友们过上一个快乐的秋天和冬天！下面就让我们一起看看2018年秋季番有哪些值得期待的动漫吧~ 《关于我转生成为史莱姆的那件事》《关于我转生变成史莱姆这档事》原作为轻小说，后来改编为漫画。无论为原作小说还是漫画，销量都非常的高。据原作轻小说最新12卷透露，本作累计销量突破450万部。于是终于在众人期待中迎来了动画化。故事讲述平凡的主角三上悟意外的被杀后转生到异世界成为一只史莱姆的故事。悲催的主角一直被当做经验怪，被各路人马蹂躏来蹂躏去。不过我们的主角不是一只普通的史莱姆，而是一只披着史莱姆的皮，有着龙傲天实力的史莱姆。于是一段最强史莱姆的异世界传奇故事就此展开。 《妖精的尾巴》大结局妖尾是是笔者超喜欢的动漫之一，当然也是最热门的热血动漫之一。2009年开始连载然后断更，到现在已经快10年啦，终于迎来了最终的大结局。小伙伴们是不是早已望眼欲穿了呢？还记得妖尾公会的符号以及手势吗？ 《魔法禁书目录》第三季魔禁相信不用我安利了吧，跟妖尾一样，又是一部只要你在二次元，你就不会不知道的人气动漫。当麻的撩妹手可是广大宅男最最羡慕的神级技能！还有强大无比又人见人爱的炮姐，也要回归了哦~ 《刀剑神域 Alicization》又一个经典神作的续作，最完美的游戏番， 笔者的最爱之一！看到这里相信热爱动漫的小伙伴们，已经兴奋起来了吧？今年10月的新番，给力程度真不是一般的给力！然而，这不仅仅是全部哦。除了这些注定不凡爆炸性的人气作品，还有许多动漫值得期待！如《青春期笨蛋不做兔女郎学姐的梦》《哥布林杀手》《我喜欢的妹妹不是妹妹》，都是人气轻小说改编而来，应该不会让人失望滴，让我们一起期待10月的到来吧。"},{"title":"关于阿里文学和唐家三少那点事的一点看法","date":"2018-09-16T02:50:12.000Z","url":"/20180916-1.html","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["唐家三少","/tags/%E5%94%90%E5%AE%B6%E4%B8%89%E5%B0%91/"],["阿里文学","/tags/%E9%98%BF%E9%87%8C%E6%96%87%E5%AD%A6/"]],"categories":[["生活学习","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"],["杂谈","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%9D%82%E8%B0%88/"]],"content":"唐家三少的妻子死了。 看到这个消息的时候，其实也没太多感觉。可能有点惋惜吧，毕竟年纪轻轻的， 来这世上走一遭， 没活够就走了， 划不来。 不过生老病死，也是很平常的事，这世界每天无数的人死去，无关富贵贫贱。 照理说，世人应该早就司空见惯了吧。但这世上总有喜欢搬弄是非，搅动舌根的人，特别是在我们中国，貌似也是几千年的文化流传下来的。 这不人死没三天， 阿里文学的同学秉承良好传统，又开始了讨论： ![阿里文学员工对三少妻子去世的讨论](/images/2018/09/20180916001.jpg) 果然是意料之外，却又意料之中的恶毒。和鲁迅先生说的一样，中国人惯于看别人笑话。或许有人觉得该纠正一下，不能一棍子打翻一船人，只是少数老鼠屎坏了一大锅汤。先不忙，这个话题后面再说。 先看看阿里文学的同学一逞口舌之快的后果： ![阿里文学致歉](/images/2018/09/20180916002.jpg) 看到这里我和大家的直接反应一样：活该吧，叫你不留口德，做惯了恶事，迟早遭报应。 不过反应过后，总觉得哪里不对。 这种事情，不是应该发言不当的当事人本人致歉，私下解决的吗？ 他们是毫无悔悟之意，还是声音太弱小，以至没人注意到，或者是被选择性忽略了？ 网络上的放大现象，也是众所周知的了，一些本来可以平静解决的事，在网络上演变成了风暴，也不是一起两起了。发声双方力量的不对称，可以千百倍的放大相应的伤害。 这个事爆出来，估计阿里文学那两个同学失了工作不说，已经千夫所指了吧。 肯定会有人说，这样不对吗？ 弘扬社会正能量的事，谁敢谁能说不对。 只是阿里文学，大张旗鼓的致歉，干脆果断的开除员工，是否真的妥当呢？ 看起来义正言辞，其中借机宣传的意味，明眼人都看得出来吧。 恶毒的话，估计不少人多多少少说过一些，没说过的也有不少至少想过一些吧，这种话说出来确实会对人造成伤害。不过若对方是个正常人，这种伤害也在承受范围内吧？让当事人公开道歉，公司给予一定的的处罚应该就可以了吧？ 一句话直接开除，永不录用，这是一个有人情味，有担当的公司应有的反应和举动么？ 一般公司都会宣传公司是一个大家庭，员工都是家庭的子女。你家子女犯了错，你能一棍子打死或者直接抛弃么？ 当然每人都知道那种说法只是一句谎言，公司和员工本质就是剥削和被剥削的关系。他们被抛弃，只是因为跟触动的利益相比，他们的剥削价值无足轻重。 我不知道三少的粉丝有多少，估计几千万甚至上亿吧。三少的问责对阿里文学自然是影响巨大。网络文学领域的竞争如此的激烈，一个三少能发动的，不仅仅是他和他的粉丝，还有他的作者圈子以及圈子作者的粉丝。阿里文学岂能不重视？甚至借机搞了一波宣传，既避免了损失，又省了广告费，还树立了正义的形象，一举数得，两个小员工算得了什么。 只是在这跪舔大佬的行为面前，阿里文学又一次赤裸裸的向我们展示了这是一个强权可以肆意妄为的世界。劳动者权益保护法不过是一张无足轻重的薄纸，早已被戳的千疮百孔。 当然站在个人的角度，三少的态度和能力是值得让人欣赏的。自己和自己在乎关心的人受到了伤害，无论对方是谁，都要勇于讨回公道。他做到了，相信阿里文学的处理会让他解气。 只是假如发声的不是三少，而是一个无足轻重的普通人（当然普通人阿里文学的同学才不会讨论，这里假如），阿里文学还会大张旗鼓的致歉开除吗？我相信阿里文学可能不会屑于一顾。 再来说说看笑话的事。中国的看客文化已经被说烂了，不是你看我笑话，就是我看你笑话。前面阿里文学的同学看三少的笑话，接着众网友看这两同学的笑话。我写这篇东西，似乎也摆脱不了看笑话的定义或者被看笑话的命运，当然更可能根本没人看更别谈笑（^_^）。 为什么中国人这么爱看笑话？ 看笑话的人在哪里都有，只有在中国特别的普遍，以至于成了“看客文化”。这个现象的形成原因比较复杂。网络上有比较全面的回答（百度百科：看客文化）。 归根结底，自古以来，中国人从没有争取到真正的幸福和自由。社会的不公，权力的腐化，奴役和压迫，一直阴魂不散的萦绕着中国人，让国人祖祖辈辈喘不过气来。自顾尚且不暇，如何有多余的善心给与身外的世界，更别说是给与那些既得利益者。现代社会虽然物质文明比过去丰富了许多，但是国民面临的生存压力和幸福感却没有提升多少。生存压力面前，看看热闹和笑话，嘲讽和诋毁他人几下，就成了很多人唯一能忘却自身，发泄情绪的方式了。 当然这里不是想为阿里文学那两位开脱，只是借机发散一下。纯粹的个人品德和修养问题，是无法用言辞或者大环境什么的掩盖的。中国自古有慎言慎微，修身修德的先贤教育，有些人非要吃了教训才知道后悔。 鲁迅先生曾说：对于这样的群众没有法，只好使他们无戏可看倒是疗救，正无需乎震骇一时的牺牲，不如深沉的韧性的战斗。 但是现在网络媒体这么发达，让人无戏可看是不可能的了。所以只能寄期望与更根本的改变，让人民真正的幸福和自由起来。只是不知道这种改变的期望和王健林“一个亿”的小目标，哪个更靠谱。"},{"title":"基本排序算法","date":"2018-09-15T15:26:07.000Z","url":"/20180915-5.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"],["排序算法","/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["数据结构与算法","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"]],"content":"以前存于百度文章上的东西，刚学编程那会儿总结的基础知识。 基本的排序方法，主要包括冒泡、选择、插入、希尔、快速、归并和梳排序。 算法复杂度冒泡、选择、插入排序时间复杂度均为O(N^2)，快速、归并排序时间复杂度为O(N logN)，希尔排序的时间复杂度为O(N^(1.5))键索引排序的时间复杂度为O(N) （依然可以用上面的算法，只是排序的不是容器中的元素，而是其索引，即Indirect Sort） 1. 冒泡排序(Bubble Sort):一趟循环从后向前依次比较相邻元素，如果反序则交换位置，就像冒泡一样。(当然也可以向后冒泡)。通过一趟排序确定开头(或结尾)的元素，然后循环处理依次确定每个元素。优点：简单 2. 选择排序(Selection Sort):选择排序是通过一趟排序确定最小(或最大)元素的当前位置然后和开头交换， 然后循环处理依次确定每个元素优点：一趟排序只交换一次元素位置即确定一个元素，比冒泡快，对于大型对象速度较快消耗资源较小 3. 插入排序(Insert Sort):它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序）， 因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：(1)从第一个元素开始，该元素可以认为已经被排序(2)取出下一个元素，在已经排序的元素序列中从后向前扫描(3)如果该元素（已排序）大于新元素，将该元素移到下一位置(4)重复步骤3，直到找到已排序的元素小于或者等于新元素的位置(5)将新元素插入到该位置中(6)重复步骤2~5 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 4. 希尔排序 (Shell Sort):希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。步长可以有各种取法，但需注意：应使步长序列中的值没有除1以外的公因子，并且最后一个步长必须等于1。 5. 快速排序（Quick Sort):快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：(1) 从数列中挑出一个元素，称为 “基准”（pivot），(2) 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面 （相同的数可以到任一边)。 在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。(3) 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递回的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递回下去，但是这个算法总会结束。因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 快速排序的时间复杂度为O(N logN)在最坏情况下，快速排序使用约(N^2)/2次比较快速排序需要栈空间来实现递归，经过改进栈的最大深度可降为O(log n) 6. 归并排序(Merge Sort):归并排序（以从大到小为例）：假设一个容器内，前半部分与后半部分分别有序（即两部分分别排序完成），将前面一半复制到一个新的容器里（原容器空出一半），然后将原容器里的后半部分元素跟新容器里的元素依次比较，较小的放到原容器前面去，最后有剩余的一个容器剩下的元素全部是最大且有序的，直接全部copy到原容器里。这样整个容器就变得有序了。而前半部分与后半部分我们依然可以假设他们各可以分成前后有序的两段，递归进行归并，最后则可以得到一个只有2元素的容器，可以直接比较交换了。 7. 梳排序(Comb sort):梳排序是改良自泡沫排序和快速排序，其要旨在于消除乌龟，亦即在阵列尾部的小数值，这些数值是造成泡沫排序缓慢的主因。相对地，兔子，亦即在阵列前端的大数值，不影响泡沫排序的效能。在泡沫排序中，只比较阵列中相邻的二项，即比较的二项的间距(Gap)是1， 梳排序提出此间距其实可大于1，改自插入排序的希尔排序同样提出相同观点。梳排序中，开始时的间距设定为阵列长度，并在循环中以固定比率递减，通常递减率设定为 1.3。 在一次循环中，梳排序如同泡沫排序一样把阵列从首到尾扫描一次，比较及交换两项，不同的是两项的间距不固定于1。如果间距递减至1，梳排序假定输入阵列大致排序好，并以泡沫排序作最后检查及修正。 "},{"title":"【转】为什么女生不喜欢男生打游戏","date":"2018-09-14T19:22:09.000Z","url":"/20180915-1.html","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["游戏","/tags/%E6%B8%B8%E6%88%8F/"],["男女相处","/tags/%E7%94%B7%E5%A5%B3%E7%9B%B8%E5%A4%84/"]],"categories":[["生活学习","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"],["杂谈","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%9D%82%E8%B0%88/"]],"content":"转自QQ说说的文章，也是时隔多年的旧文了，不过感觉内容不错，收集起来。 我也不知道 朋友圈里一对跨国情侣吵架了。 女生怒不可遏的在评论里大声斥责男友变心。 说是最近一个礼拜对她态度骤冷， 每天都不知道出门去干什么， 电话也是应付了几声就挂。 评论区阴谋论和渣男论趋于爆炸。 狗头铡马上都要推出来了。 女主就差飞美国找男友面分了。 我思考了一下， 给男主发了一条微信：“Pokemon go?” 半个小时后，收到了一个“嗯。” 沉冤得雪。 亲爱的，他只是出门去抓皮卡丘了， 并不是变心了，只是刚刚发行的Pokemon go比你优先级稍微高了一点点而已。 当然这话我没有和女主说， 因为玩游戏而发生的惨案那么多。 我没有必要再造杀孽。 90年代的游戏厅门口每隔几天就有小男孩被父母混合双打， 但是隔不了几天，他又会出现在游戏厅里，一副无所畏惧的样子。 大人说这叫死不悔改，我们却一致觉得，这叫专一。 我就是喜欢玩游戏， 喜欢到不顾一切。 男生都爱玩游戏。 不论是姚明的盗贼，周杰伦的阿狸， 还是王校长的炉石传说， 一个男生一生至少都会有一个挚爱的游戏。 去年7月份的时候， 我接待了一个央企的高层， 年近半百的金丝眼镜西装男， 因为涉及到公司的重要战略合作，一路小心谨慎不敢多言。 路途无聊，作为央企的高层，副部级干部， 他掏出手机玩起了消灭六边形。 一瞬间气氛就缓和了。 所以你看，游戏多么拉近人和人之间的距离。 我有一个好友，高考结束后， 因为只顾着Raid不陪女朋友导致分手， 虽然舆论一致惋惜， 但是我一直没有劝他复合， 因为我觉得， 为了游戏能和你提分手的感情是挽回不了的。 因为她和你的三观差太多了。 女生们沉浸在韩剧的罗曼蒂克里不可自拔， 一口一个老公，一眼一个深情， 我们最多只是笑着骂她们花痴。 但是男生只要一玩游戏， 动辄就是多大的人了那么幼稚， 就知道玩游戏，玩这个有什么用吗？ 玩这个能玩出房子车子来么？ 你别说，还真能。 别说买车买房， 国内游戏主播年入过亿都大有人在， 为啥，因为有市场啊。 玩游戏的男生数量绝对不输看韩剧的女生， 但是你什么时候看到男生因为女生看韩剧而分手的？ 都是兴趣爱好，不公平啊！ 其实玩游戏的男生， 大部分人品都不会太差。 闲暇的时间， 有那么多黄赌毒可以去做， 他们没有去做， 而只是打打游戏而已。 游戏过程中可以摘下耳机和你斗两句嘴， 需要帮忙的时候甚至还能离开电脑去帮你， 天哪，你知道这有多爱你么？ 让你试试韩剧不能缓存不能回看， 走开一会儿发现你的欧巴死了， 你再来看看我们放下游戏去帮你， 多么纯粹，多么伟大。 你们还有什么不满足的？ 我一直觉得我媳妇儿特别好， 不为别的，就为那句， “没事儿，等你这一局打完先。” 妈的，天使 ————匿名（负能墙）"},{"title":"Re:从零开始的异世界生活txt下载","date":"2018-09-13T18:55:22.000Z","url":"/20180914-1.html","tags":[["ACGN","/tags/ACGN/"],["从零开始","/tags/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"],["异世界","/tags/%E5%BC%82%E4%B8%96%E7%95%8C/"]],"categories":[["ACGN","/categories/ACGN/"]],"content":"《Re：从零开始的异世界生活》 日本热门轻小说，已改编为TV动画，作者长月达平。挺好看的轻小说，剧情新颖跌宕起伏，人物塑造生动深刻，能给读者带来很强的代入感和深深的感触。下面附有小说全集的下载链接。 剧情简介在从便利商店回家的路上，少年菜月昴突然被异世界召唤。在还没有搞清楚这个世界的时候，他莫名其妙的就死亡了， 然后他一遍遍的重生一遍遍的死亡。在这个魔法和武力发达的世界，少年昴唯一的力量就是重生。为了守护最重要的人们和弄清事情的真相，少年努力抗拒着绝望，勇敢地面对着残酷的命运。 下载链接：  密码:6heh "},{"title":"【转】搞ACM的你伤不起","date":"2018-09-13T12:44:06.000Z","url":"/20180913-4.html","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["ACM","/tags/ACM/"]],"categories":[["生活学习","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"],["杂谈","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%9D%82%E8%B0%88/"]],"content":"2012年转载放在百度空间的文章，发泄式创作，很有意思的写法，有让人想看下去的神奇魔力~文章出处(该链接已失效) 劳资六年前开始搞ACM啊！！！！！！！！！！从此踏上了尼玛不归路啊！！！！！！！！！！！！谁特么跟劳资讲算法是程序设计的核心啊！！！！！！尼玛除了面试题就没见过用算法的地方啊！！！！！！谁再跟劳资讲算法之美算法的力量，劳资一本算法导论拍死你啊！！！！！！！！那是搞ACM的入门书啊！！！！特么的入门书就一千多页啊！！！！！！！还没有习题答案啊，学完了你特么都不知道自己到底会不会啊有木有！！！！！！然后你就得看lrj的黑书啊！！！！！！还是特么的没有习题答案啊！！！！那书难的一B啊！！！！人家一个“显然”得出的结论够你想一礼拜啊有木有！！！！一个课后题够你想几个月啊有木有！！！！然后还有一堆堆的书啊！！！！每一类算法都足够写一本书啊！！！！每本都是砖头一样啊！！！！还都特么是英文的啊！！！！也有中文翻译版啊！！！！！！翻译得跟屎一样啊！！！！你看的时候得把它再变回英文才能懂啊！！！！！！有木有！！！！！！ ACM的题目类型是没有范围的啊！！！！！！动态规划有木有！！！！数据结构有木有！！！！图论有木有！！！！！！计算几何有木有！！！！！！数论有木有！！！！！！要写两三百行的模拟题有木有！！！！！！特么连物理题化学题都有啊！！！！！！还有理论上就不可做的NP难问题啊！！！！！！特么理论上不可做的题也有人能AC啊！！！！坑爹啊！！！！ 课本上学的东西完全不给力啊！！！！！！你以为学过一个最长公共子串就是懂动态规划了啊！！！！！！树型的有木有！！！！状态压缩的有木有！！！！插头的有木有！！！！而且特么写出来就超时啊！！！！！！你得四边形优化啊！！！！你得斜率优化啊！！！！你得队列优化啊！！！！特么恨不得把要算十年的程序优化到一秒啊！！！！你以为学过一个二叉搜索树就是懂数据结构了啊！！！！！！平衡啊旋转啊红啊黑啊有木有！！！！伸展啊随机权重啊合并啊拆分啊有木有！！！！！！你以为学过一个Dijkstra最短路就是懂图算法了啊！！！！！！特么的图里有几百万个点啊！！！！！！得用堆来优化啊！！！！而且边权要是负的就不对了啊！！！！还有环啊！！！！而且特么的你根本看不出是最短路问题啊！！！！！！为神马最短路算法可以用来解不等式啊！！！！还有网络流啊！！！！特么的课本上的算法铁定超时啊！！！！！！你得看论文去研究神马Dinic啊SAP啊！！！！！！而且你还是根本看不出是网络流啊！！！！！！网络流是在图上来求啊！！！！特么的图在哪里啊！！！！特么的八竿子打不着的问题都能变成网络流啊！！！！！！ 这些你都学会了啊！！！！想参加比赛了啊！！！！发现想拿个成绩非常难啊！！！！！！校内选拔赛就好几百人报名啊有木有！！！！！！最后只能剩下十几个啊！！！！人家都是竞赛保送的啊！！！！！！中学就学了好几年了有木有！！！！怎么比的过啊！！！！！！进了校队以后你就不要想寒暑假了啊！！！！！！夏天劳资全身脱光了涂满花露水半夜刷题有木有！！！！！！冬天劳资跑遍校园找不到一个开门的食堂有木有！！！！！！而且特么老外的在线比赛都在半夜啊！！！！！！！！在机房通宵是常事啊有木有！！！！！！ 比赛是三个人啊！！！！但是只有一台电脑啊！！！！！！特么的ACM组委会连多买几台电脑都不肯啊！！！！！！队友占着机器你就只能干着急啊！！！！！！想把他踹一边儿去啊！！！！！！没机器你就得在纸上调试啊！！！！！！你的脑子就是个CPU啊有木有！！！！你要是摊上一个啥都不会，连读题都误导你的队友，你就死定了啊！！！！！！不怕神一样的对手就怕猪一样的队友啊！！！！ 你终于参加区域赛了啊！！！！一百多个队啊！！！！！！还有一大堆打星号的高中生们啊！！！！！！都是全国前几名级别的有木有！！！！还有一大堆打星号的老不死们啊！！！！！！毕业了还要来诈尸啊！！！！一开场那气球呼呼地挂啊！！！！你还没读完题人家已经AC了啊！！！！而且最先过的不一定是最简单的啊！！！！人家故意在误导你啊有木有！！！！！！比赛要五个小时啊！！！！结束了以后脑子都抽筋了啊！！！！人家做七八道题，你连一半都不到啊！！！！！！拿个毛的奖啊！！！！去个毛的总决赛啊！！！！！！去了总决赛也是被虐啊！！！！！！老毛子们更尼玛不是人啊有木有！！！！！！连清华都被虐啊有木有！！！！！！ 你拿着一堆Honorable Mention毕业了啊！！！！想找工作啊！！！！谁说懂算法很容易找到好工作啊！！！！都特么要项目经验有木有！！！！劳资成天盯着一个黑乎乎的控制台窗口！！！！哪有时间做项目啊！！！！！！同学们都是网站啊桌面程序啊做过一堆啊！！！！人家对面试官侃侃而谈啊！！！劳资只好说劳资除了算法啥也不会啊！！而且其实算法也没学会啊！！！！！坑爹啊！！！！ 终于工作了啊！！！！发现算法神马的完全用不上啊！！！！稍微复杂点的算法都有现成的库可以用啊！！！！！！要懂Shell编程有木有！！！！要懂多线程有木有！！！！要懂Socket有木有！！！！要懂分布式有木有！！！！要懂J2EE有木有！！！！要懂设计模式有木有！！！！ 要懂以下省略三千字有木有！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 总之搞ACM的上辈子都是脑细胞死光钻到牛角尖里出不来的天使啊！！！！！！你伤不起啊！！！！！！"},{"title":"常用的linux安全处理","date":"2018-09-12T16:54:04.000Z","url":"/20180913-3.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/tags/linux%E5%9F%BA%E7%A1%80/"],["linux安全","/tags/linux%E5%AE%89%E5%85%A8/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["linux基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/linux%E5%9F%BA%E7%A1%80/"]],"content":"一、登录安全1.1 修改ssh端口修改SSH默认端口，可以降低各种暴力攻击的风险。SSH端口默认为22，编辑/etc/ssh/sshd_config, 修改Port，然后重启sshd服务。 1.2 设置最大登录尝试次数设置较低的最大登录场是次数，可以降低SSH服务器被暴力攻击成功的风险。编辑/etc/ssh/sshd_config，取消MaxAuthTries注释符号#，设置最大密码尝试失败次数3-6，建议为4： 1.3 SSHD强制使用V2安全协议编辑/etc/ssh/sshd_config，文件以按如下方式设置参数： 1.4 设置SSH空闲超时退出时间设置SSH空闲超时退出时间,可降低未授权用户访问其他用户ssh会话的风险。编辑/etc/ssh/sshd_config，将ClientAliveInterval 设置为300到900，即5-15分钟，将ClientAliveCountMax设置为0-3。 1.5 确保SSH LogLevel设置为INFO确保SSH LogLevel设置为INFO,记录登录和注销活动。编辑/etc/ssh/sshd_config，取消LogLevel注释符号#，将其设置为INFO: 1.6 禁用root登录root用户权限太高，不小心可能引起误操作。可以禁用root登录，以拥有sudo权限的用户登录。 1.6.1 创建sudo用户: 1.6.2 禁用root登录：编辑/etc/ssh/sshd_config，将PermitRootLogin配置为no： 1.7 采用密钥对登录，禁用密码登录1.7.1 设置sshkey登录:在客户端本地创建sshkey，将公钥id_rsa.pub内容拷贝到远程服务器用户目录下~/.ssh/authorized_keys文件中。 1.7.2 禁用密码登录:编辑/etc/ssh/sshd_config，将PasswordAuthentication配置为no： 二、密码安全2.1 禁用空密码登录编辑/etc/ssh/sshd_config，将PermitEmptyPasswords配置为no: 2.2 密码复杂度检查使用非密码登陆方式如密钥对，请忽略此项。编辑/etc/security/pwquality.conf，把minlen（密码最小长度）设置为9-32位，把minclass设置为3或4。如： 【minlen=密码最小长度，minclass=密码至少包含小写字母、大写字母、数字、特殊字符等4类字符中的种类数）】 2.3 设置密码失效时间使用非密码登陆方式如密钥对，请忽略此项。编辑/etc/login.defs，将 PASS_MAX_DAYS 参数设置为 60-180之间，如： 同时执行命令使root用户设置生效： 2.4 设置密码修改最小间隔时间使用非密码登陆方式如密钥对，请忽略此项。编辑/etc/login.defs，将 PASS_MIN_DAYS 参数设置为7-14之间,建议为7： 同时执行命令使root用户设置生效： 2.5 确保密码到期警告天数为7或更多使用非密码登陆方式如密钥对，请忽略此项。编辑/etc/login.defs，将 PASS_WARN_AGE 参数设置为7-14之间，建议为7： 同时执行命令使root用户设置生效： 三、系统权限管理3.1 设置用户权限配置文件的权限建议执行以下5条命令： 四、配置安全组策略 待整理。 五、服务和辅助工具 禁用不需要的服务： 安装fail2ban, 监控服务器攻击。 六、应用服务安全6.1 mysql安全 修改mysql端口：mysql默认端口为3306，编辑/etc/my.cnf (查看自己mysql配置文件位置), 找到端口修改，然后重启mysqld服务。 6.2 redis安全 修改redis端口：redis默认端口6379，默认绑定127.0.0.1，编辑/etc/redis.conf(查看自己redis配置文件位置），修改端口后重启服务。 七、做好服务器运维 检查服务器运行的服务和开启的端口 其他待整理。 "},{"title":"软件质量模型的六大特性","date":"2018-09-12T16:08:43.000Z","url":"/20180913-2.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["软件工程","/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"],["质量模型","/tags/%E8%B4%A8%E9%87%8F%E6%A8%A1%E5%9E%8B/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["软件工程","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"]],"content":"一、功能性：1、适合性： 软件是否提供了相应的功能2、准确性： 软件提供的功能是否正确（用户需要的）3、互操作性： 产品与产品之间交互数据的能力, 例如word对其他文档的支持能力4、保密安全性： 允许经过授权的用户和系统能够正常的访问相应的数据和信息，禁止未授权的用户访问5、功能依从性： 国际/国家/行业/企业 标准规范一致性 二、可靠性： 产品在规定的条件下，在规定的时间内完成规定功能的能力 1、成熟性： 软件产品为避免软件内部的错误扩散而导至系统失效的能力（主要是对内错误的隔离）,exception等的处理2、容错性： 软件防止外部接口错误扩散而导致系统失效的能力（主要是对外错误的隔离）3、易恢复性： 系统失效后，重新恢复原有的功能和性能的能力。 三、易用性： 在指定使用条件下，产品被理解、 学习、使用和吸引用户的能力 1、易理解性： 软件交互给用户的信息时，要清晰，准确，且要易懂，使用户能够快速理解软件。2、易学性： 软件使用户能学习其应用的能力。3、易操作性： 软件产品使用户能易于操作和控制它的能力。4、吸引性： 四、效率性： 在规定台条件下，相对于所用资源的数量，软件产品可提供适当性能的能力 1、时间特性： 平均事务响应时间，吞吐率，TPS（每秒事务数）. 软件处理特定的业务请求所需要的响应时间。2、资源利用性： CPU,内存,磁盘IO,网络带宽,队列,共享内存. 软件处理特定的业务请求所消耗的系统资源。 五、可维护性： “四规”， 在规定条件下，规定的时间内，使用规定的工具或方法修复规定功能的能力 1、易分析性： 分析定位问题的难易程度2、易改变性： 软件产品使指定的修改可以被实现的能力3、稳定性： 防止意外修改导致程序失效的能力4、易测试性： 软件功能验证的难易程度 六、可移植性： 从一种环境迁移到另一种环境的能力 1、适应性： 适应不同平台2、易安装性： 被安装的能力3、共存性： 软件产品在公共环境中与其它软件分享公共资源共存的软件。4、易替换性： 软件产品在同样的环境下，替代另一个相同用途的软件产品的能力。 "},{"title":"软件开发流程","date":"2018-09-12T16:06:28.000Z","url":"/20180913-1.html","tags":[["编程基础","/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["软件工程","/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"]],"categories":[["编程基础","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"],["软件工程","/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"]],"content":"软件开发的五个阶段1. 问题定义 确定当前面临的问题，讨论软件开发的目标和可行性。 2. 需求分析 确定可行性后对软件需要实现的功能需求进行分析，收集和归类，根据需求制定好开发计划。 3. 软件设计 根据需求分析设计软件框架和结构，选择相应开发环境和工具，为顺利编码打好基础。 4. 程序编码 制定编码规范，根据需求分析和软件设计进行编码，实现所需要的功能。 5. 软件测试 编码模块完成，阶段性完成，和整个软件整合完成后，开发人员和测试人员都需要对软件功能进行验证，修复存在的错误和漏洞，测试分为白盒测试和黑盒测试。 软件开发的流程1. 瀑布式开发 古老的开发模型，产品的整个开发流程严格按照以上软件开发阶段进行。 2. 迭代式开发 将整个产品的功能划分为多个不同层次的小项目，从简到繁，从局部到整体，渐进式的实现产品目标。 产品每实现一阶段目标，称为一个迭代。 迭代式开发的优点： 1. 降低风险 2. 得到早期用户反馈 3. 持续的测试和集成 4. 提高复用性 3. 螺旋式开发 和迭代开发有异曲同工之妙，也是从简到繁，渐进式的实现产品。 不同之处是，螺旋式开发更注重风险控制，重视客户在开发中的反馈。产品在开发中根据客户反馈进行需求分析和风险评估，选出适合当下的最佳方案，产品根据反馈在调整中螺旋上升，不断完善。 4. 敏捷开发 敏捷开发没有明确清晰的定义，只有一个清晰的目标：快速响应需求变化。 为了实现这个目标，敏捷开发要求团队之间， 团队与客户之间紧密协作，高效沟通，快速确定需求变化，适时根据需求变化进行迭代更新， 快速将需求变为实现，以便于快速获得下一波反馈或者尽快进入下一阶段开发，不然产品在软件开发的任何阶段发生阻塞。 其实各种名称并没有太多的意义，开发过程不是教条，只要是有利于降低成本和风险，有利于提高开发效率的方法，都可以采用。实际开发过程中，只要注意及时发现问题，积极解决问题，保持紧密协作和沟通，这样就可以了。"},{"title":"【转】留学爱尔兰五年辛酸：中国，你知道我有多爱你吗？","date":"2018-09-12T12:44:06.000Z","url":"/20180912-4.html","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["留学","/tags/%E7%95%99%E5%AD%A6/"],["爱尔兰","/tags/%E7%88%B1%E5%B0%94%E5%85%B0/"]],"categories":[["生活学习","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"],["杂谈","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%9D%82%E8%B0%88/"]],"content":"转自香港理工大学CMSA论坛(原地址内容已丢失)快十年前的文章了，从大学论坛转来的，一直放在QQ空间里，感觉是挺好的东西，翻出来挂博客里吧。 我初到爱尔兰，是2001年的初春。 记得是在布达佩斯转的机，转机时，其他国家的旅客都走了，一些自中国来的，被要求检查行李。海关人员脸色暗淡，显得很不耐烦，耽搁了很久才得以入关。 候机时，和两个中国留学生聊天，其中一个是来自北京的女孩子，她的目的地是德国，也是第一次出来。另一个男孩子据说在塞浦露斯都呆了几年了，这次是回来探亲。 等候转机时，我们聊了半天，聊到了俄罗斯的光头党和德国的新纳粹，临分别时，彼此道了祝福。那女孩子还特意说了一句：在爱尔兰好好的，给中国人争口气。这句话至今我还清晰的记得。然后，我们各分东西。 到达都柏林时已经是晚上十点了，走出大厅，我四下寻找着接我的人，看了很多接人者举着的牌子，但怎么也找不到接我的人。后来看到一个爱尔兰男子，举了个牌子，上面写着我的名字，我之所以没看到，是因为他把牌子拿反了。 出机场，上了他的车。行驶在高速路上，天空很清澈，月光如水，感觉天很低，仿佛一伸手就可以摸到。 一路无话。一小时后抵达我的语言学校所在的小镇，那接我的爱尔兰人却怎么也找不到门牌号，前前后后找了半个小时，嘴里不停的骂着：WHAT THE FUCKING NUMBER， STUPID！ 终于在人的指引下找到了我的寄宿家庭。那时已经是晚上十一点半了。 寄宿家庭的男主人没说什么，帮我把一个最重的旅行包搬上了楼（我住他家的阁楼），我道了谢。箱子放好，他招呼我下楼去厨房，爱尔兰人喝咖啡，或者围坐谈事情很少在客厅，而是在厨房。到了厨房里，他们一家都在，两个儿子，两个儿媳，我说：这是我第一次出国，我的英语不好，请原谅。他们说不用客气，他们抽烟时，问我要不要，我指了指他家的一个怀孕期间的儿媳妇，说：她怀孕，我不能在她面前抽烟。他们说没关系，抽吧，于是我抽了一根自己的中南海。当两个儿子即将离开时，女主人很客气的告诉我注意事项：若抽烟，可以在厨房抽，在卧室不能抽，并且不要喝太多酒，尤其不能喝的大醉，这是不可以的。 那天晚上很冷，爱尔兰人不爱烧暖气，阁楼里冻的不行，我只好穿着毛裤睡了。我在这户爱尔兰人家里住了一个月，因为饮食和生活习惯的差异，加上房租贵，所以我和很多中国学生一样，只住了一个月就搬了出去。临走时，我特意把被罩和枕套都洗好叠好，然后吸了一遍地，确定阁楼很干净了，才离开。后来，听以后住进他家的中国学生说，那对夫妇经常在他们面前提起我，说我是个GOOD CHINESE BOY。 记得与我一起去学校报道的，还有一个上海的学生，我们都被安排在初级班，后来才知道，那上海学生英语出色，于是他被很快转到高级班了。我那个班当时有十个人，除我以外，都是辽宁来的，多来自沈阳，本溪和抚顺。我们的老师是个年轻的爱尔兰女人，很友善，显然受了不错的教育，说话也很客气。我就在她的班里学习，学了几周后，被调往中级预备班，就是比初级高，比中级低的班。 四月，我的一个同学问我要不要去工作，我说，当然要了。他说他有个别人介绍的工作，但是很远，自己没有交通工具，去不成，问我要不要去。我想都没想的就答应了，要了地址，我也看不明白，就要了一辆出租车，大概花了十镑（那时爱还没有欧元），足足在时速七十公里的状态下开了十五分钟才到，后来才知道，那家餐馆离我住的地方十二英里。路上，我从车窗看到一个中国的男孩子在路上走着，当时也没多想。事后得知，他也是去那家餐馆找工作的，但他比我狠，是走着去的。我因为坐了出租车比较快，所以面试成功，他晚了一步，于是没有要他。 那家餐馆不大，是传统的爱式餐馆，古香古色的桌椅和沙发，还有台灯。老板没问太多问题，只是问我学校的名字，并且要我去办税卡， 从此，我的半工半读的生活就开始了。 因为远，我没有车，在一位室友的帮助下买了一辆很旧的自行车，十五爱尔兰镑。我在周末工作，从两点开始到午夜，骑车去骑车回，路上来回要花一个半小时，就这样一来一直骑了四年。自行车换过几辆，最初买的那辆，刚刚修理好，就被当地人偷走了，再买了一辆新的，半年后，又被偷走了，三年前买了一辆，放在公寓里，先是被人用铁棍把车把砸了，估计是没偷成功，怒从心起，于是砸了一下。我没在意，几天后，还是被偷走了。对此我苦笑，始知英国人为什么厌恶爱尔兰人。 说到住宿，我觉得这是中国人之间产生矛盾的一个重要因素。因为房租贵的很，为了节省，大家便自发的合伙找房子，然后分摊房租和各种帐单，但这是件矛盾的事情。房租虽然便宜了，但是分歧也出来了。首先是清洁问题，现在的学生都小，生活自理能力不强，没有人去自觉维护房子的卫生，通常是，你不干净我也不干净，垃圾堆在那里，谁也不去清洁，于是房东来看房子时，大为不满，当场要收回房子的事情太多了，原因就是你没有很好的维护房子，起码的卫生标准都没有达到，房东很不高兴。至于房子脏到什么程度，我亲眼见到的一幕是：厨房里污水横流，洗手间爬出了蛆。不夸张，我亲眼看见的，那几个租房子的学生后来被告了，法官命令他们支付所有恢复费用大约700镑，那几个学生一商量，连夜搬家跑了。后来那家房屋中介声称再不租房子给中国人。 中国合租房还有一个麻烦就是，学生流动性大，今天在这里，过段时间都去那里上大学，不稳定，于是有人提出：既然是大家约好找房子，那么你要是搬家，你就得找个人顶近来，因为你走了，大家分摊的房租就贵了，所以即使你搬了，你还得接着交房租，直到有新人顶近来。那段时间就是这样的。不过也是没办法，一个房子里住好多人，难免有合不来的，有摩擦，搞的很不愉快。今天约好一起租房子，没三天，找了个女朋友，于是又说不跟着租了，要和女朋友一起住，有些人一点诚信都没有，也是没有办法的事情。另外象帐单的分摊也有麻烦，有的人回国一个多月，却不得不交同样的费用，有的人整天使用烤箱什么大功率电器，交的费用也是一样，时间一长，就有摩擦，大家都不开心。好多原来是朋友的，在这房子问题上都翻了脸，我说就是太计较了，没有必要的事情。 其实我还是觉得中国学生大部分都是不错的，岁数不大，却知道如何去生活，自己打工挣钱，多数学生是不给家里添麻烦的。但欠缺的就是一个良好的生活习惯和团体精神，大多比较自私，心胸也很狭窄，受不得一点委屈，有时候多交几欧元电费都能吵的天翻，这就不应该了。 爱尔兰有很多语言学校，水平参差不齐，素质有高有低，。有很多学生，名义上是读书来的，结果到了以后，不读了，一味的打工挣钱，为换取每年的签证，很多学生都会报一所挂名的语言学校，以此来申请签证，事实上根本不去上课，学校的首脑们因为都有中国人做助手，也深知里面的名堂：开一张录取信，学期结束，我给你张出勤率为百分之八十的证明信，你以此换取签证，我收钱，大家开心。这样的学生和语言学校在爱尔兰有很多很多，真正去读大学的学生不到两成，其余的都是混，有课不上，打工挣的钱都吃喝了，或者攒了下来邮寄给了家里。如此打工，上课时间就没有保证，到结束时，出勤率往往不够，签证官一个个的很冰冷，总是象对犯人一样对待中国人，我看的到他们眼神里对中国人的厌恶。有时候我想问问他，为什么说话的语气不能友好些，后来做罢了，一是因为我们自己不争气，二是因为他们是爱尔蓝人，我不指望任何爱尔兰人懂的礼貌。 有很多学生到了这里，都染上了赌博的恶习，我见过不少一输就是几千欧元的学生，没钱了就问别人借，借了不还，接着赌。我有时候看着他们都觉得可惜，我认识一个朋友，本来是想读大学的，后来因为赌博，输光了所有的钱，还问家里邮寄了许多钱，最后又输了，上学的希望基本没有了，现在他只是在餐馆洗盘子，发了工资就去赌，拼命的工作，人都累的脱了型，我不知道以后他会怎么样，但是我希望他别这么下去，可是谁都知道，他是不会听的。 我先后工作了两家餐馆，都是洗碗。第一家的老板年龄很大，人很计较，但是心地不错，几乎没有发生过什么不愉快的事情。我工作努力，他也都看的见，并且经常夸奖我，于是员工们也对我很友好，从没有刁难过我，彼此的关系呈现一种良性循环的状态。事情就是这样，你只要做的努力，时间一长，他就说你好，千万别耍滑头，爱尔兰人笨，但是在这方面不笨，狡猾的很。我因为几年如一日的卖力工作，于是赢得了一个好的口碑。但是后来工作的第二家餐馆就不行了，因为店大，老板有钱有势，员工又多，所以人和人之间关系很冰冷，就是一个钱字，有些爱尔兰员工也有明显的种族歧视，对中国人说话象对狗说话，什么活都让你干。 依我看来，即使再大的餐厅，没有爱尔兰人也一样可以运转的很好，反正他们也不怎么干活，重活累活都给中国人和那些东欧人干，自己却站着聊天，我曾经私下对一位黑人朋友抱怨，他说，冷静点吧，这是人家的国家。我说，他们有些人对我们说话就象囚犯，爱尔兰人太粗鲁。那黑人说，不对，你说错了。他们对自己人说话为什么很少粗鲁？因为我们皮肤的颜色和他们的不同罢了。 最有意思的是，爱尔兰人会在你最忙的时候，客人做多的时候，要你去做其他事情。他们从来不会顾及你的繁忙程度，你若稍有质疑，他们就显得不快，他们想的只是自己。此时，如果你争辩，他们就会说你懒。我想说，我不是懒，有些事情本不是我的工作，你要我帮忙，我没时间去帮，况且你自己可以做的，为什么你会说我懒呢？ 在爱尔兰五年，说真的，我几乎没有一天快乐过。经常可以听到同学和朋友被爱尔兰人欺负的事情。一位同学在快餐店做事情，动作有些慢了，客人抓起杯子就砸，嘴里还骂着：你他妈的混蛋中国人。结果打了起来，那爱尔兰人被打了出去，围观的其他爱尔兰人大喊：打的好！应该打他，他给爱尔兰人丢脸。由此可见，爱尔兰也有懂道理的好人。尽管如此，但是我还是深深的觉得，种族主义在这个国家已经开始蔓延了。小孩子岁数不大，上来就敢辱骂你，我觉得不是孩子的事情，是他们的父母灌输的结果，在爱尔兰，有很多酒鬼，他们不工作，领政府救济，每天就是喝酒。他们的孩子出生在那样的家庭，于是也得不到好的教育，等这些孩子长大了，等他们有了自己的孩子，还是没有好的教育，恶性循环，于是导致爱尔兰有一批这样的人，本国人他们惹不起，于是就攻击外国人。 如果说究竟有没有快乐过，我想，只有一次。那是一个冬天，我从别的镇子回来，从火车站往家走，很晚了，一路上下着小雪，狂风大做。我走在路上感觉很舒服，因为路上很安静，没有向我哇哇怪叫的爱尔兰酒鬼，也没有中学生问我要香烟，小流氓们也躲在家里。路上清静了，尽管天气恶劣，可是，与爱尔兰人的粗鲁野蛮相比，即使是坏天气算的上什么呢。一想到这里我就觉得悲哀，也就是这样的想法促使我做出回家的打算，我要离开这个不友善的岛国了。 机票已经定好。再过几天，我就可以回中国了，如果你问我是不是会留恋，我回答的干脆：不会，绝对不会。我是个讲良心的人，在这里我读了书，爱尔兰人给了我工作的机会，使我洗盘子挣了几千欧元。我怎么都会感谢他们，但是我想说，这不是一个君子的国家，他们表面上欢迎你，背地却抱怨你挣走了他们的钱，你挤掉了他们的就业机会。可是我反问：洗碗的工作爱尔兰人做吗？我究竟拿走了他们什么？ 如果没有，何以如此对待我们这些外国人呢？我曾经在一次班里的辩论中说：我们中国人没有拿走你们什么，我是个学生，以我为例，我们付的学费高出欧盟的学生几倍，我课余洗碗挣最低工资，我们中国学生打工挣了你们的钱，但是都化成学费还给了你们的政府，当我们回家时，我们不带走什么，带走的只是一张文凭，和一口流利的英语。你们失业增加，是因为你们的经济结构出现了问题，是因为你们的工作效率过低。是因为白种人走向了落没，白种人百年来因为富裕而变的懒惰，变的不思进取，你们这也不做那个不干，修一条一公里的马路竟然要花两个半月，是你们自己的缓慢，于是才有了中国和印度的崛起，不是我们抢了你们的机会，而是你们把机会扔到了一边，我们之所以走向富裕，不过是中国人把你们用来度假喝咖啡的时间用来辛勤工作而已。中国强大了，你们说中国威胁，中国落后了，你们又说中国人不文明，然后闯进来抢走我们的文物，说什么替我们保存。白种人在中国受到礼遇，而中国人在欧洲受尽欺负。如此反差，令人不得不心寒。 有爱尔兰学生抱怨中国货到处泛滥，而且质量低劣。我说，这就是个事实，以一只20欧远的长毛绒玩具为例子，实际中国工厂的利润是很低很低的，只是靠数量来加以弥补，大部分钱还是被你们自己的贸易公司拿去了，只给了我们一点点可怜的利润，却要求质量水平一流，这是不可能的，那些学生辩不通，便说：那你们可以不做嘛，我说，你们这样讲就没了讨论的意义，成抬杠逗气了。 在爱这么多年，好人也有，但是能让我记住的好人，我实在是想不起来了。我今年岁数不小，按理说应该公平客观的评价一个国家和它的国民，可是我斟酌再三，觉得最公平的评价就是：这是个彻底的农民国家，爱尔兰人没什么理想和追求，效率低下，但一旦他们把你当朋友，也会对你很好，比如跨国婚姻，你嫁给爱尔兰人了，他自然对你好些，这谁都知道。几乎所有的爱尔兰人的思维都很奇怪，举个有意思的例子：他让你去找东西，你找不到，那么有两种情况，一是那东西根本就不在，二是放的太靠里，你无法找到。此时你如果说你找不到，他们首先想的就是你说谎，或者你笨蛋，却不去想想，那东西也许早就被拿走了。由此可见爱尔兰人的自负和固执。 我一直觉得，耐心是种美德。我记得在国内时，有外国人向我问路，我说不清楚，于是用笔写下来，他就看懂了。在爱尔兰你就别指望了，因为这里有浓重的口音，即使连英语国家，比如加拿大来的人有时候都听不清楚。爱尔兰人对外国人说话，从来都不说清晰标准的英语，总是含含糊糊的，说的又很快，让人听起来很困难，说一遍你听不清，他勉强再说一次，到第三次他就叹气翻白眼了，意思是，你怎么这都不懂呢？我曾和一位北爱尔兰人（英国公民）谈过这个问题，他很蔑视的说：爱尔兰人完全可以把英语说的很清晰，但是爱尔兰人却不说，搞不清他们是怎么想的。他问起我中国的情况，我说，在我们的国家，受过教育的人都可以讲标准的普通话，只有老人讲不出。他点头说：这是受过教育的表现。我想，当时我们双方的含蓄意思是一样的：爱尔兰的教育程度实际是不高的，国民是缺乏素质的。 有次走在路上，有一群小青年对着我没来由的怪叫，还学着说中文，然后骂着FUCKING CHINIESE。我说，是的，我讲中文，我是个中国人，你是爱尔兰人，你却只会讲英语。那些孩子说：那又怎么样？我说，你们连自己的爱尔兰语都忘光了，你们在讲人家英国的语言。他们喜笑着说：这很正常吧。我当时就没了争辩的心情：一个国家的国民，青少年是未来和希望，却说出这种没有丝毫荣誉感的话，忘却了被英国人屠杀殖民了几百年的历史，这样的民族，叫我如何尊敬它呢。 我很奇怪为什么国内把爱尔兰说的天花乱坠，说什么它是世界上教育程度最高的国家之一，绝大多数人都受过大学教育，还说它是世界软件中心。我对此哭笑不得，完全是不胡说八道了。在爱尔兰人的概念里，你读个职业学校，就是高等教育了，所谓职业学校就相当中国的中专，只学技术，不学其他知识。他们的大学教育也是那么回事，除了几所知名的大学还可以，其他的就算了，大学上课时，一屋子上百个人，老师也是总请假不来。考试题也没那么难，只要看看书就能过，除非一点书不看的人，那是过不了。有时候我就想，我花那么多钱读这个书，我学到什么了？ 就他讲的那些东西，我抱着字典，上网查查资料也能学下来，我怎么就非得花几万欧元读这个没有实际用处的文凭呢。当然，这是说气话了，书还是有用的，还是要读，不管在哪里，我也就是发发牢骚而已吧。说到爱尔兰是世界软件中心，就太搞笑了，什么叫软件中心？你有自己的研发机构吗？你有一个整体的，系统的发展规划吗？国内的媒体在胡说八道，爱尔兰根本就不是什么软件中心，充其量也就是个软件打包中心。 我来爱尔兰几年，每年都有中国学生被打死，不知道其它国家是不是也这样，有中国人之间的仇杀，也有被爱尔兰人活活打死的。记忆中有一个二十九岁的东北小伙子，在大街上被一群爱尔兰青少年辱骂，口角中，被人用铁棍打碎了头骨，在都柏林的医院里不治身亡。最近发生的一起命案是在去年，有盗贼在深夜进入一中国学生的家，偷窃时被发现，那个来自中国南方的学生被刺数刀当场死亡。时候他的父母来处理丧事，所有大报都有头版刊登，我印象最深的一副照片是爱尔兰星报的，照片上是一位痛哭的母亲，手拿儿子的遗照，标题：WHY DO YOU HATE US。 联想到留园前几天登的新闻：六名中国学生在打篮球时遭爱尔兰人群殴，我的心彻底的凉了，我当时就一个想法，我要离开这里。。。。 贴子写到这里，已经写不下去了。我绝对不是意气用事，偏激的评说爱尔兰和爱尔兰人，我说的都是事实而已，没有一点夸张的成分，如果有在爱的朋友看到，请你们为我做个证，告诉大家，我是不是在耸人听闻。 为什么中国人在外面总是受尽欺负呢，我糊涂了，我们并没有侵犯别人什么，我们只是努力的学习和工作，洗盘子做苦力，我们没做什么对不起白种人的事情吧？ 象西班牙那样大规模的排挤华人，烧了鞋。好多人都会说，是那些温州人不讲商业道德，以至于招来敌视。我却不这么看，在欧洲，你即使守了道德，讲了规矩，他们一样排挤你，只不过另找一个借口而已，白人就是这样，他竞争不过你，就跟你犯浑，就打骂你。以西班牙为例，你西班牙既然打开国门做生意，说什么平等竞争，凭什么我们的鞋不能进去？你们自己人做不好生意，反怪外来的人抢你们饭碗，争不过就抢，抢不过就打，打不过就烧，这样粗鲁算什么事情呢？好多人都误会了，觉得温商不讲规矩，其实多数温商还是可以的，所从事的生意都是走法律程序。西方人动不动就说中国不好，说我们掠夺，那么我们掠夺你们什么了？回顾历史，看看英国，法国，德国和葡萄牙什么的，哪个欧洲国家不是在世界上大肆掠夺？ 白种人把非洲都瓜分干净了，现在还说别人掠夺成性，我觉得很可笑。 中国就是要强大起来，就是要武装到牙齿，只有强大了，才不会受欺负。我常常想，我要活的尽量长些，因为我想看到那么一天：那时，我们中国人不用再背井离乡，中国变的富裕，那些外国人蜂拥而来打工挣钱，学习我们的文化，我想看到那一天，我们的移民官也象审犯人一样盘问着那些外国人。 出了国才明白一些事情。 中国，你知道我有多么爱你吗。。。。"},{"title":"旧文收集系列：读沉思录的一点感想","date":"2018-09-11T19:22:09.000Z","url":"/20180912-3.html","tags":[["读书","/tags/%E8%AF%BB%E4%B9%A6/"],["哲学","/tags/%E5%93%B2%E5%AD%A6/"],["沉思录","/tags/%E6%B2%89%E6%80%9D%E5%BD%95/"]],"categories":[["生活学习","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"],["读书","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E8%AF%BB%E4%B9%A6/"]],"content":"几天来， 零零散散， 沉思录读了有一小半， 震撼愉悦之余， 各种念头迭起不穷，颇多感慨。几年来， 几乎从来不写文字， 最多发发说说， 几十字倒还容易， 但是想到要写个稍微长点的“文”， 总感觉千难万难，仿佛疏远很久的亲戚，难再想走动。本来想着暂且忍耐待读完再写，却又觉得不如顺其自然，到读完时，或许已没法战胜惰性和遗忘。而最终促使我决定写点什么， 是在读着读着又想起所读译本中何怀宏给本书做的序中的一些看法， 颇不认同， 注释之余犹觉不吐不快， 于是在各种综合之力下勉力一番。 &emsp;&emsp;在读之前， 我并不知道这是怎样的一本书。名声自然是听过的， 不过也仅限于知道其名列西方古代著名哲学作品之一而已。本着对哲学的一点爱好， 以及对老庄孔孟诸子百家之类的耳类生茧， 某一天忽然涌起想看看西方哲学是怎样的一种强烈的想法， 于是去当当网搜了下, 于是苏格拉底， 柏拉图， 亚里士多德，尼采， 《理想国》，《忏悔录》，《沉思录》等等一系列从中学时代就如雷贯耳的名字重新出现在眼前， 给人一种亲切， 安心， 满足而又愉悦的感觉。陌生的， 古老的智者先贤， 总能让我产生毫无道理的崇敬之情， 虽然或许我并不知道他干了什么， 又或许我知道后立马把他打入地狱。我不知道这是不是一种人类的共性，但我知道对于我这是肤浅， 愚昧和不够理智的表现。 &emsp;&emsp;从这一堆中书中， 我选择了《理想国》和《沉思录》两本， 一是因为便宜，二是因为这两本在我匆匆了解中在历史上更早。理想国的对话模式看了一点点， 暂时看不下去， 于是看起了沉思录。 其实原本我对于我能看多少一点信心也没有， 和大多数人一样，我原本以为这种书大多都是枯燥乏味的 ， 类似已经泛滥的鸡汤文学。其中第一让我兴趣高企且去探索的就是这本书的作者： 马可·奥勒留。他是古罗马帝国的一个皇帝， 五贤帝之一， 相当于中国的唐宗汉祖式的人物。皇帝出哲学类的书， 这在中国历史上似乎难以想象。 事实上古罗马帝国的政治文明先进， 对比我们引以自傲的华夏五千年文明来看， 也是无比震撼的。那还是在2000+年前， 古罗马古罗马就建立了共和国政体，有明晰的权利， 义务， 公民， 国家， 法律的概念。 2000多年前啊， 当今社会， 当人们享受现代科技文明成果和精神文明开放时， 有多少人在谈到古人时， 潜意识中把他们当做未开化的愚昧者， 或者没有见识到完整全面理论的可怜者？不要否认， 藐视古人的优越感确实在我们的思想意识中发芽生长着， 在我们的遗忘， 随意歪曲和玩笑中发生着。 读《沉思录》， 让我对于那种虚无缥缈的敬畏落到实处， 因为这位皇帝在两千多年前， 就站在一个普通人的角度， 给我们讲述了发生在他自身， 同时也发生在我们身上的同样的问题和困扰， 并且给予了我们他自己的解决方法和背后蕴含的深意和原则。我想所有人， 无论是似我这种而立之年， 抑或是耄耋之年， 在读这本书时， 都会发自内心的感觉自己是一个学生， 在倾听老师的敦敦教诲。 因为这是一本写给自己的书， 而自己的理智是自己最好的老师。 &emsp;&emsp;我并不清楚西方哲学的派系， 这点可能要读过《西方哲学史》才知道， 而这个计划在读过沉思录之后， 不知道会不会有意思。大约知道的一点是， 西方古代哲学研究范围很广， 将人， 社会， 自然， 宇宙作为一个整体来讨论， 所以涉及有社会学， 政治学，科学， 神学等诸多学问。当然这些专业东西暂时不是我的关注点， 我在意的依然是有关人的部分。在读沉思录中， 我发觉我对神学有了一点与以前不一样的认识。在以前， 提到神学， 我总是将之等同于神秘，宗教，迷信，莫须有等内容， 似乎中国无神论也是这么宣传的， 在无神论者看来， 无论无论神学是多么的宣扬善， 本质依然是以愚民手段来达到统治目的的工具。而沉思录中， 我看到古罗马神明的文化， 是为其哲学理论模型找到的合适的解释， 就和当今物理学家们为解释宇宙现象提出的平行宇宙， 大爆炸， 虫洞， 黑洞等理论一样。他们并不迷信， 也不崇拜， 只是用来辅助当时的知识水平解释宇宙中的现象和思考如何运用来服务社会和完善自身。 古罗马哲学和当代科学与哲学的共同一点是， 它们的出发点都是辩证的， 既考虑过如果存在怎么样，不存在又怎么样。比如在卷二中有一段“如果有神灵存在， 离开人世并非一件值得害怕的事情， 因为神灵将不会使你陷入恶； 但如果他们确实不存在， 或者他们不关心人类的事务， 那生活在一个没有神或神意的宇宙中对你意味着什么呢？”又比如“这要么是一个秩序井然的宇宙， 要么是一团胡乱聚在一起的混沌， 但仍然是一个宇宙。但怎么可能在大全中没有秩序， 而在你之中却存在秩序呢？” 虽然在这种问题中， 古代哲学家们选择了神明和秩序，但是正是这种辩证思维， 使得我们感受到一种深刻的开明和睿智。 &emsp;&emsp;沉思录中将人看做三个部分组成： 身体， 灵魂， 神明。 他们认为神明掌控着宇宙的秩序， 在创造人类时， 分出了自己的一部分赋予人类， 所以每个人心中都有属于自己的神明。而植入人们心中的神性则被认为是理智。 里面有一段概述“身体， 灵魂， 理智， 感觉属于身体， 爱好属于灵魂， 原则属于理智。” 在我的理解中， 灵魂等价于是人的欲望和情绪， 而理智则包含所有人类普世价值中认为是好的东西，比如正义，公平， 宽恕， 谦虚， 以及忍让， 节制等道德上的东西， 也包含自然界中正常发生的事情， 比如生老病死， 平静的接受这些事情， 不惧怕， 不逃避， 不因此大喜大悲； 这些都被认为是理智的表现， 是神性的一部分。序的作者认为该派思想崇尚个人修养， 清静无为， 但是缺乏进取之意， 或许是因为他们生在一个混乱的年代， 面对挫折感觉到个人的无能为力而产生的精神安慰。 粗看起来， 这本书中的思想确实和道家无为有很多共同之处， 但是我想这么认为只是考虑了表面， 而没有认真对待作者反复提到的原则： 既如果事情无差别的发生在不同的人身上， 比如死亡， 这被认为是神的意志， 所以需要已平静的心态来接受；对于的恶的现象， 人们也需要忍受， 但这种忍受是针对自身，不要产生恶的情绪，因为这样也只会毁伤自身， 但是并没有说不要通过合理， 理智的手段进行抗争。实际上， 这一派的哲学家并非无为， 而是实际行动派， 他们对于空谈和诡辩之人有着足够的警醒， 书中多次有提到。 同时书中无数次的告诫自己不要分心， 赶快去做自己理智上正确的事。 “丢开你的书吧， 不要再让你分心， 分心是不被允许的”“记住你已经把这些事情推迟得够久了， 你从神灵得到的机会够多了， 但你没有利用它。”“你错待了自己，你错待了自己，我的灵魂， 而你将不再有机会来荣耀自身。每个人的生命都是足够的，但你的生命却已近尾声，你的灵魂还不去关照自身，而是把你的幸福寄予别的灵魂。”“属于身体的一切只是一道激流， 属于灵魂的只是一个梦幻，生命是一场战争，一个过客的旅居， 身后的名声也很快落入忘川。 那么一个人靠什么指引呢？ 唯有哲学。 ” 随手摘来就是一段段直指自己生活烦恼和困惑的原因和所思所想， 仿佛一个来自两千年前的亲切的老师和朋友的教导。 很高兴我会产生读这本书的想法， 为伟大的哲学家马可·奥勒留致敬， 也感谢译者何先生的优美文字！"},{"title":"旧文收集系列：犬夜叉","date":"2018-09-11T18:55:22.000Z","url":"/20180912-2.html","tags":[["ACGN","/tags/ACGN/"],["犬夜叉","/tags/%E7%8A%AC%E5%A4%9C%E5%8F%89/"]],"categories":[["ACGN","/categories/ACGN/"]],"content":"上大学的时候，一个暑假提前收假，挺无聊。偶从同学那里看到犬夜叉的DVD。权当无聊打发时间，便借来一看。此后也就很少接触，虽然当时看的还颇有点欲罢不能。 &emsp;&emsp;大概也是在前段时间，偶然看到一段评论是关于犬夜叉的大结局的。瞟了两眼，竟然记住了犬夜叉已然完结的这样一个事实。有时候就会颇想知道，这个故事的结局是怎么样的，可能因为比较懒也没有刻意的去找过，只是在想会是一个什么样的结局。及至后来拷到它的全集，竟然能够从头到尾的看了一遍。当然其中也有跳过的部分但基本上算是全篇通览。看完之后感觉就像完成一个任务一样。在看大结局之前，虽然桔梗之死在自己的意料之中，但是还是很想看看作者是怎样的处理这样的一个结局，怎样平衡戈薇、桔梗和犬夜叉之间的感情。琥珀的存活也在自己的意料之中，但还是很想看看琥珀会以一种怎样的方式存活下来，还有就是奈落最后的收场方式是怎样的，以及杀生丸性格的塑造这些算是让自己能够再次从头看下来的一个源动力。本身没有考据的习惯也就不关注那些细节，推敲那些情节，只能算是在看完这样一个自己觉得还是比较浩大工程之后发发牢骚而已。 &emsp;&emsp;我想犬夜叉首先最能吸引一个人的地方便是桔梗的复活。戈薇的穿越只是是故事开始的一个噱头。真正故事的展开是在桔梗复活之后。从这里开始散发开各条情感的脉络线条，将整个故事的血肉丰富起来，当然始终认为他们三者之间的情感是这个故事的骨干。不知道有多少人喜欢桔梗这样的一个角色。忧伤、孤独、憎恨和爱恋这些复杂的负面情感让她笼罩上一层冷艳、孤傲的气质，这样的气质和她本身作为一个死人复活的身份是相得益彰的，但同时这样的气质又与她还在活着时的孤独坚持是相适应的。第一个印象最深的地方，就是夕阳西下，半江瑟瑟半江红之时，她在扑到的时候犬夜叉用船桨扶住了她，然后将她搂在怀里。那样的景象或许是因为用回忆的方式来不断浮现，所以总是有一种淡淡的忧伤情绪在里面，看起来都很美好，但犹如镜中月水中花一样，都已不在。甜蜜的记忆算是一部分，但更加反衬出现在的无奈。好像看到最后也已经不再憎恨奈落，仿佛故事的发展就应该是这样的一样，很难其去描述若是当初没有奈落的介入，犬夜叉和桔梗甜蜜的生活下去的景象。有时候会想，若是戈薇没有介入到其中，桔梗的复活成为现实，那么犬夜叉和桔梗是不是会再次一人在明，一人在暗的生活下去，很难去描述。有时候即使知道作者应该不会安排桔梗和犬夜叉最后在一起，但是也总会带有那么一点想法。爱情有时候是自私的，因为没有那种可以同时容纳两个人的爱情，犬夜叉对桔梗的感情是真实的，对戈薇的感情按情节发展也需要是真实的，作者出了一道难题就是，戈薇作为桔梗的转世，怎样才能够摆脱桔梗的影子，虽然她的行事风格和桔梗有着很大的差别，但是作为犬夜叉而言，首先的第一印象是桔梗。也就是说戈薇用一种怎样的方式来宣告自己在犬夜叉的心里是一个独立个体的存在，犬夜叉怎样能够把戈薇和桔梗当做两个完全独立的个体来看待。虽然在故事的后来，通过戈薇救桔梗这样的一个方式似乎得到了很好的解决，个人也觉得这似乎是一种比较好的方式因为至少这样的话反而看起来桔梗的死反而易于接受一些。但是个人觉得这样的交待并不是很清楚，桔梗死后，戈薇扮演了一个抚慰着的角色，似乎桔梗的死方能把犬夜叉的感情释放出来在戈薇身上一样。但同时戈薇身上的一个特点让我想起一个典故，具体也不是很清楚，说的是一个很有名的哲学家，在救一只陷入泥塘的蝎子的时候，被蝎子蜇了一下，但是他仍然将这只蝎子救出，路人很奇怪的问他说：这毒蝎子都蜇你，你为何还要救它。他说：蝎子蜇人是它的本性，它蜇人只是因为它的本性而为之，并没有错，而我救它也来自于我的本性，我为何要因为它的本性而不接受自己的本性。戈薇在感情方面更多的时候是自己在和自己做斗争，她内心的无助、脆弱都是自己在与自己的斗争中表现出来的。在犬夜叉的整个故事结构里面，戈薇的各种挣扎和困惑，似乎都在想说戈薇并不是一个完美的人，但是这样的斗争反而让人觉得，戈薇太过于完美，这样的完美反而无法让更多的人产生共鸣。我们都会庆幸犬夜叉有戈薇这样一个人陪在身边是何等幸运的同时，也都会觉得要是犬夜叉可以和桔梗一路走下去也很不错。因为桔梗是脆弱的、无助和忧伤哀愁的，她和犬夜叉的过往充满了悲情的色彩，人们会倾向于可以去挽救或是补偿一段破碎了的美好，而往往对于现在固有的美好反而不会感受到，也不会体会到为了这份现在固有的美好有人所付出的努力和艰辛。也有可能是因为和桔梗的死亡、犬夜叉封印五十年相比较而言，戈薇的付出还不够，爱情似乎总要有沧海桑田、海枯石烂的感觉才能够刻骨铭心。 &emsp;&emsp;也不知道作者在整个故事的构架之初，对于戈薇和桔梗两个人的角色定位是什么样的。一个是过去的旧爱，一个是现在的新欢，两个人透过时空的相遇，必然要演绎出一场情感纠葛的大戏。但还好作者并没有落入俗套，作者本身对于命运的轮回带有一种悲天怜悯的情怀，虽然强调命运的不可抗拒性但同时也看到的是在这种不可抗拒的命运前的一种抗争和追求的美好。或许戈薇和桔梗本身就是同一个人，一个代表着不可挽回的过去，一个代表着现在。人们往往都会对过往带有一种美好的怀念，而对现实总是带有一种不可否认的忽略。所以桔梗的悲伤可以一直存在，而戈薇自己的忧伤总会觉得是可以克服的也是应该要去克服的，且不会意识的现在的经历慢慢也会变为美好的过往，这算不算是人本身的一种劣根性。但还有另外一种假设就是戈薇和桔梗代表着爱情不同的阶段。这里的不同阶段也就是故事的不同发展阶段，在故事的情节里面，桔梗代表着的是热恋时的感觉，而戈薇代表的是慢慢成熟后所应该开始承担的责任。两者之间的冲突碰撞，便让一个人在怀念过往的历史中沉浸在里面。犬夜叉的感情脉络在每次面对桔梗的时候，都是无法自拔的。这样的感觉和最初的感觉有很大的关系在里面。随着认识的深入，可能当初的哪一个桔梗都会随着时间的流逝变为了戈薇，那么是不是就让以往的哪一个桔梗留在记忆里独自悲伤怀念，还是在接受戈薇和桔梗就是同一个人的事实，依然能够涌起心中的爱恋，而不是沉浸在以往的美好里面。我们也可以把戈薇和桔梗之间的纠结理解为同一个人在认同自我和追述过往的斗争。奈落的介入是破坏了桔梗和犬夜叉的元凶，但是要是用这样的观点来看，或许这样的阴谋只是犬夜叉和桔梗之间随着现实生活中所诞生出来的一些必然的矛盾。他们和奈落的战争过程也是一个在化解自身和相互之间矛盾的过程，甚至可以理解为一个自我救赎的过程。 &emsp;&emsp;还有另外一种假设。也还是那一句来老话，在对的时间里遇到对的人，才会有刚刚好的爱情。桔梗和犬夜叉的爱情似乎可以理解为是对的人在错的时间里相遇。作为巫女的桔梗和作为半妖的犬夜叉，在他们慢慢成长的岁月里相互之间建立起一种依靠的爱恋。作为巫女的桔梗是孤独、冷傲但同时又是脆弱的，作为半妖的犬夜叉也是敏感的、残缺的。他们都是在一个大圈子之外的独立个体，对大圈子里的生活有着同一样的向往，这样的孤独让他们两颗心慢慢的走到了一起。但是他们之间的生活还没有足够的交汇，他们的爱恋是美好的，就像久在沙漠中行走的人相互之间成为了彼此的绿洲。但是这样的绿洲毕竟是在沙漠之中，他周围的土壤是贫瘠的，无法给他们的爱情提供足够的养分和时间来等待他们慢慢的成熟。当奈落介入到其中之时，用一种最简单的方法和最直接的方式便破坏了他们可以慢慢成熟的空间。因为他们之间的依赖太过于简单，他们相互之间的爱情太过于孤独，这种仅仅存在于他们之间的爱情，使他们对对方的依赖完全的建立在了对方的行为之上，就像是期望值越大，那么可能一点点的瑕疵都会造成最后的完全溃塌。当然，他们之间的恋爱是有着很多让人羡慕的因素，简单、快乐、依靠。那时候看着桔梗的微笑也会为她感到开心，但是这种微笑更多的反衬出后来一路只能自己独行的桔梗的孤独。似乎扯远了，桔梗代表着哪一个最后未能和你走到一起的恋人，无论当初你们有着什么样的过往。因为曾经拥有的那些简单的快乐，渐渐变成珍藏的记忆，当所有的往事都无法追忆之时，你内心里所涌起的淡淡悲伤，便会与桔梗的悲伤共鸣，那时候你从桔梗的身上，似乎看到了你自己。所以那时候桔梗代表着的也是你自己那份曾经不可挽回的记忆。张爱玲说过这样的一句话“也许每一个男子全都有过这样的两个女人，至少两个。娶了红玫瑰，久而久之，红的变了墙上的一抹蚊子血，白的还是“床前明月光”；娶了白玫瑰，白的便是衣服上的一粒饭粘子，红的却是心口上的一颗朱砂痣。”此话似乎颇有道理，可以把之看成是心理学的小说版。而佛语版也有类似的说是在凡人看来人生最珍贵的东西有两样，一样是得不到。一样是已失去。算不算的一种普众心理，我不知。但是在这里，桔梗所代表的或许就是那一个得不到和已失去的床前明月光和朱砂痣。当然在这里戈薇没有是蚊子血也不是饭粘子。只是桔梗的存在对于每一个观看者来说，都会有一个影子在脑海中浮现，若这个浮现的影子和你现在的爱人相一致，那么恭喜你。如若不一致，也权当看看，珍视现在才是真实的。至于是不是蚊子血和朱砂痣，是床前明月光还是饭粘子和犬夜叉这部动漫的本身并没有什么联系，插了一段而已。 &emsp;&emsp;对于许多一直关注着犬夜叉的朋友来说，犬夜叉的结束和它的结局带来的是一种怎样的感觉我不得而知。毕竟如若一个人在一件事情上持久的关注过，那么它的结束或多或少都会带来一种伤感。这种伤感既有对故事结束的一种淡淡失落，即使结局再怎么完美。也有对自己时间流逝的感伤。对于二十岁左右的最大的动漫受众面来说，犬夜叉恰好在青涩的年华开始，然后在自己渐渐在社会中沉沦、挣扎、拼搏中结束。嘘嘘感慨一番在所难免。但是由此所带来的一些记忆才是伤感的根源。这个年龄是一个青黄不接的年龄，纯真渐渐远去，醇厚还在未到火候。有着激情万丈，也会感叹梦想的渐渐远去。当然这也可能只是在这个故事结束的时候的一点小小愁思。笃行任然会是生活的主基调，就像在犬夜叉结束的时候。每个人都有着自己的方向，主色调是光明清新的。 &emsp;&emsp;犬夜叉讲述了很多个角色。有点像西游记的感觉，只是在这里不是去取经，也没有那么多有后台的妖怪。每个故事里面强调对人性的刻画。实际上有时候通过动漫，可以感觉到日本大和民族的一种民族性格。他们屈服于强者，乐于欺负弱者的性格在整篇动漫里随处可见。他们必须通过征服来获取力量，就像岛国资源的匮乏，必须要通过征服外界才能够获得自己成长的力量。感觉又有点扯远。提到犬夜叉不可避免的要再次提到戈薇和桔梗，一个动、一个静。似乎代表的是两种不同类型的女子，但是很难具体的下一个定义，都说女孩子是水做的，因为是水所以就没有固定的形态，既可以小家碧玉，若江南水乡。也可以河东狮吼，若瀑布临顶。也会用善变来形容一个女孩子。有人用猫来形容女子，一个女子的猫性有着不一样的理解方式。在故事中都有这样的一种思想，那就是死亡若因为有意义的存在，便可以忽略死亡的本身。死亡在这里成为了一种救赎的模式。对于诸多的阶段性角色而言，死亡让他们的灵魂变得憎恶，因为未完成的愿望而导致心智的迷失。最后又从心智的迷失中被拯救出来，然后就是面带微笑离去。这一次方才是最后的死亡。为什么这么说，桔梗的复活是怀着一个再想见到犬夜叉的意念而导致的又一次轮回。最后她的再次死亡，似乎已经从这样的执念中走了出来，她得灵魂在这次的死亡中方得到了解脱。这样的过程多少是让人心碎的。因为无论哪种死亡，若一旦离去，便终结了所有的可能。我一直觉得，最后她的放弃不是因为她看开了，而是所有的东西都变得不再可能，在清楚的认识到这点之后，孤傲的她只有任其离去，而隐藏着内心极大的悲伤，最后这样的悲伤幻化成微笑的泪水。终无法回去，只能在最后的一刻躺在你的怀里，姑且欺骗自己这就是永远，那些曾经的记忆就这样随风而逝吧。那朵冷艳、孤傲开在寒潭里的花朵，终于凋谢在璀璨的星空之下。未曾来过，也未曾离开。 &emsp;&emsp;四魂之玉，开始的时候我认为它只是一个穿针引线的作用。给了这些人凑在一起，演绎故事的一个借口。但在最后，四魂之玉本身幻化之后，我方才感觉到与其说奈落是背后的黑手，还不如说四魂之玉是背后的黑手。而奈落也只是被四魂之玉利用了的一个半妖而已。有点像在打完一个个BOSS之后，哪个一直认为是最终BOSS的背后原来还有一个更大的BOSS。而四魂之玉的厉害之处在于，任何一个人都有愿望。无论这种愿望是怎么样的终将被他所利用，因为往往一个人都很难脱离开自己或是身边的人来形成愿望。一个正确的愿望，怎样才算正确。在这个故事里面，所有开始正义和善良的愿望似乎都喝这个正确无关。奈落的愿望最后原来也是如此的简单，桔梗死去时的愿望也并不复杂。戈薇最后许下的这个让四魂之玉消失的愿望，似乎也就成为了唯一一个正确的愿望。这个愿望脱离出了它能实现自己一个愿望的怪圈，因为若要实现自己的愿望，前提就是四魂之玉的存在。而唯有这个愿望它解决了这个矛盾。四魂之玉，有点像八卦、黑白两仪的对立统一。不知道这样的感觉是错误还是正确，随着剧情的发展，尤其是在故事的最后，大部分的角色都被作者赋予了双重性。奈落的强大和对他的憎恶因为这样的一个愿望，而顿觉可悲。原来他最后所要达成的愿望始终未曾脱离那最初的想法。风之使者神乐化风离去，最后一刻寻找到风的本性——自由，应该为之开心还是失落。短暂的一刻拥有，是否就能代表了所有。也罢，放歌南山外，饮酒闹市中。 &emsp;&emsp;杀生丸，随着故事的不断发展，这个角色的色彩越来越丰富。冷酷、高贵、骄傲加上精致的面孔。估计对小女孩有着致命的杀伤。执着于铁碎牙而对于四魂之玉毫不感兴趣，可以毫不留情的攻击作为半妖的弟弟犬夜叉，也可以用生命去保护作为人类的小玲。对于人类他可以是高高在上的存在，也可以是一个冷酷的施救者。手握能拯救生命的天生牙。他最大的困惑来自于对于父亲的无法理解，这种无法理解源自于他对力量的追求以及自己和犬夜叉一样作为儿子看起来的不同待遇。他的出现，也常与明月相伴。甚至还带有一点忧郁感觉的他，给四魂之玉之外抹上了一道华丽的色彩。 &emsp;&emsp;法师和珊瑚，这两个人必须作为一个整体来说。这个既是故事情节发展的需要，也是因为他们两个有着相同的遭遇。那就是都亲眼看着自己的家人的离去。法师的生活态度是一种很放荡不羁的，但是在这样的放荡不羁的背后，却是对未知死亡的一种深深的恐惧。打个比方而言，假如我现在对你说，你估计只能活到80岁，可能你会觉得无所谓。但是换一个可以准确预言的人对你说，你随时都有可能死亡。那么这种慢慢割肉的感觉肯定会让你背负极大的重担，因为一种未知和不确定性，所以可能你连等死的机会都没有。一方面是对于生活无比的向往，另外一方面是对于死亡不确定的未知。在法师那看似玩笑生活的背后更多的是一个人默默承受的艰辛。对于珊瑚而言，家人的死亡打碎了童年的记忆，但是她所背负的不仅仅是家人的死亡，更多的是她的弟弟琥珀。对于琥珀不确定的生命存在，和琥珀所带来的各种后果，做为姐姐的她，也是只有自己一个人默默的承受。你只看到我的微笑，却看不到我转身时掉下的泪水。因为好此，所以他们的爱情，来得更加的沉重，但是也会有别样的芬芳。 &emsp;&emsp;说来说去，似乎忘了最重要的一个——犬夜叉。但是对于他而言，自己反而不知道应该怎么说。一个挣扎在两个人之间的人，感觉有点怪异。或者可以说，犬夜叉就是一个他自己和他的爱情一起不断成长的过程。在桔梗和戈薇面前，很难说他怎样的表达是对的。他无法忘却的过去，和他不能放弃的现在，激烈的交织在了一起。若没有戈薇，桔梗不会复活。但是若没有桔梗的提前存在，戈薇大概也不会和犬夜叉相遇。即使到最后，我也不能说，犬夜叉心中有了一个明确的概念。只能说他能够坦然的面对这两段感情而已。桔梗若没有离去，估计这样的纠结还会继续下去，只是她的离去把自己的那份空间腾了出来，犬夜叉才能够完全的把戈薇装下去。因为爱情本身的特性要求他的唯一性。但是这样的唯一性，在犬夜叉的身上遭到了挑战。因为是故事，所以有了现实中不存在的复活。但是，在现实生活中，这样的复活，也许是存在的。在不同的十字路口相遇分开，或许已经形成陌路。但是最后复活了当初那样的一种心情的时候，应该怎样选择。忘却一个人，是需要时间的。一年、两年、数十年，若时间足够长，或许我们可以忘了所有。但是在这短短的时间里面，我们很难说完全的忘记。若能忘记的爱情，也或许都不能称之为爱情。犬夜叉最终爱的是谁，或许是戈薇，也有可能是桔梗。或许他放下了桔梗，但是他们之间曾经的爱情依然会如夕阳照射下的晚霞存在某个角落里面。"},{"title":"噩耗！王雨教授去世","date":"2018-09-11T18:03:04.000Z","url":"/20180912-1.html","categories":[["生活学习","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"],["杂谈","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%9D%82%E8%B0%88/"]],"content":"今晚7点多，收到大学兄弟的微信消息：王雨教授去世了。 我一下子愣住了，虽然大学毕业八年了，我一下子想起了王雨教授的样子，不太高的个子，教我们材料学，坐在办公桌前跟我们交谈，经常言辞比较犀利，不太讨喜，但是又能感觉到他的亲切。 后来听说他特别厉害，在研究领域很有名气，是学校的终身教授，一下子心里就敬畏起来了，所以印象特别深刻。 但是怎么会！他还那么年轻！我印象中，到现在应该也才五十出头的样子吧，身体看起来比较健康，也不见什么坏习惯，怎么会就这么突然的走了呢？ 兄弟把新闻链接发给了我，看着这确实的事情，眼睛不自觉的有点湿润，心里真的难受的不行。 从新闻上看，王雨教授的去世原因还没有定论，希望别是有黑暗在里面吧。 逝者已矣，愿王雨老师泉下安息。若事有龃龉，希望善有善果，恶有恶报。 愿王雨老师的家人节哀，坚强的好好生活。 默哀。 附报道链接：知名教授、南昌大学材料科学与工程学院院长王雨去世"},{"title":"最近折腾博客的一点体会","date":"2018-09-09T12:27:21.000Z","url":"/20180909-2.html","tags":[["博客","/tags/%E5%8D%9A%E5%AE%A2/"],["cms","/tags/cms/"],["wordpress","/tags/wordpress/"],["帝国cms","/tags/%E5%B8%9D%E5%9B%BDcms/"],["织梦cms","/tags/%E7%BB%87%E6%A2%A6cms/"],["phpcms","/tags/phpcms/"],["hexo","/tags/hexo/"]],"categories":[["经验教程","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/"],["博客","/categories/%E7%BB%8F%E9%AA%8C%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2/"]],"content":"几个月来断断续续的， 有时间和心情就来弄弄cms, 博客，商城，论坛，小说站，下载站等弄了个遍， 工具也接触了帝国cms, dedecms, phpcms, wordpress, phpwind,hexo等常见cms和博客软件，算是对这个领域有了个初步的认识和体会， 下面把这段时间的感受简单综合整理下，不过因为间隔时间较长， 很多东西忘的差不多了。 wordpress世界用的最广泛的cms工具，最适合做小型门户站和博客，其数据库设计极度简洁，功能十分灵活强大，对编程很友好，基本上想要的功能都可以在后台的插件市场找到，wordpress怎么赞誉都不为过，但是用它做产品在国内却有一个关键的致命问题：卡。wordpress的内部和市场上的插件都大量的使用了国外的资源链接，因为GFW的原因，wordpress在国内体验很不好，光一个后台的选项切换都会卡的你受不了。当然目前有不少的插件提供了解决方案，比如禁用或替换google fonts，gavatar等资源为国内CDN，但是哪怕这些都做了，对比其他CMS，wordpress还是相对较卡。适宜人群wordpress 适合于有较好编程技能基础的个人或小团队，可以很舒服的DIY出自己想要的效果。 帝国cms国内使用范围较广的工具，帝国的特点是性能出众，功能强大，可以任意定制出自己想要的功能，大部分常见的网站类型都可以用帝国cms做出来。从技术上说，帝国cms数据库表很多，复杂度很高, 帝国cms的模板语法比较烧脑， 同时后台功能繁杂，UI比较简陋，这些对于帝国的使用者来说，都是一种忍受。另外，从网上流传的说法来看， 帝国cms的安全性做的不错。适宜人群帝国cms适合于三类人 拿成品做站的， 有看中的完整模板，不需要太多改动，部署后直接更新内容的。 产品规模不大，有较好技术实力的个人和团队，追求产品效果而不在乎开发体验， 能够对帝国模板模型做局部范围内的改动 有较强的技术实力的团队，能够并打算基于CMS做二次开发，打造一个核心产品的。 织梦cms织梦cms即dedecms, 目前国内使用最广泛的cms。特点是上手快，功能齐全，网络上有大量的模板可以用。因为瞄准非技术人员作为目标客户群体，织梦的门槛很低，大量非技术人员拿织梦建站，到目前为止，市面上大部分营销广告站都是织梦做的。织梦自问世以来，不停地爆出安全性问题，其性能也不是很优秀，导致市场上大部分严谨的网站都不会考虑用织梦去做。当然发展到现在，织梦的许多问题都已经弥补，国内几大CMS差距已不是太大， 织梦鉴于门槛和用户群体优势，目前仍然是最热门的CMS之一。适宜人群dedecms最适合于个人和小团队以营利为目的，基于模板快速开发出产品，为各大中小企业服务。 phpcms老牌的cms，也是使用比较广泛的cms之一，各种类型的网站都可以做，性能和安全性跟帝国cms不相上下, 其最大的特点是简洁，易用且美观的后台。市场上许多二次开发的cms系统都是基于phpcms.适宜人群跟帝国cms定位差不多，更适合于有技术团队实力用来做二次开发。 hexo基于nodejs的博客系统，没有可视化的后台，采用markdown语法进行内容创作，和github，gitee等托管平台完美协作，一键发布部署。 经过几次迁移，还是觉得hexo在整个博客开发和管理流程上最方便，是技术类博客和内容分享类博客的不二选择。适宜人群hexo 最适合于做技术和内容分享的程序员，用来创作个人空间和博客。"},{"title":"干程序几年了，说说博客这个事情","date":"2017-11-16T22:16:50.000Z","url":"/20171117-1.html","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["程序员","/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"],["博客笔记","/tags/%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/"]],"categories":[["生活学习","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"],["杂谈","/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E6%9D%82%E8%B0%88/"]],"content":"从刚开始接触网络，我就开始接触博客了，比如QQ空间，也是一类博客。也曾尝试过写，做了程序猿，基于想要积累，整理和分享的欲望，更是好几次辗转各个博客平台，新浪，CSDN，cnblogs等等， 不过都没能坚持下去。我想很多同行们都有类似的体验，尝试做，但是因为各种原因，淡忘了或者坚持不下去。这里面的原因，我觉得值得深究。 作为IT技术行业，养成写BLOG的习惯的好处，我想也不需要太多说。 这里连接两篇相关文章，说的比较清楚，排版也好看：《作为一个程序员我为什么要写博客？》， 《一个程序员的自白：我为什么写博客》 老实说，在各大博客平台写博客， 我自己也缺乏动力。因为在各大平台写博客，对于很多人来说，写一篇博客的价值和写一篇软文并没有太多不同，至于积累和分享，一方面大多数人都会有自己的积累方式，比如本地note或云note，自建git/svn仓库等； 另一方面分享毕竟是一个需要比较高觉悟的事情，而且在网络信息同质化严重的时代里，个人的分享大多数时候可能并不会带给分享者太多的价值感。 如果上面的说法适用于多数想写博客但没有行动的人的话，我想自建博客一定会更有吸引力。自建博客，可以解决以上各种痛点，一方面所有内容放到自己服务器，更放心安全，满足积累的需求和获得感；另一方面可以随意DIY自己的页面展示，同时又学习了新的技能；而对于我这种多年与web绝缘的程序员来说，自建博客增进技能和拓展职业方向的吸引力尤其重要。而对于分享来说，自建博客的分享成果直接与网站的流量挂钩，潜在的价值和收益也是巨大的，这就让人有了更多的动力。 之所以起兴写这个东西，主要是希望我的一些同僚们以及与我一样感受的人，能够早些行动起来，加入自建博客这个圈子。毕竟多年经验在那里，业内跨行可能只是一张窗户纸的厚度，不做就太浪费才学了。而且我相信，站长级的程序员交流，应该会比普通的社交带来更大的价值。"}]